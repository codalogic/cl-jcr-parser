Tests run on Fri Mar 02 18:46:45 2018

    Config - Configuration [test-config.cpp:40]
    ===========================================
    ok: config.has_jcr() == false
    ok: config.jcr_size() == 0
    ok: config.has_json() == false
    ok: config.has_jcr() == false
    ok: config.jcr_size() == 0
    ok: config.has_json() == true
    ok: config.json() == "JSON"
    ok: config.has_jcr() == true
    ok: config.jcr_size() == 1
    ok: config.jcr( 0 ) == "JCR-0"
    ok: config.has_json() == true
    ok: config.json() == "JSON"
    ok: config.has_jcr() == true
    ok: config.jcr_size() == 2
    ok: config.jcr( 0 ) == "JCR-0"
    ok: config.jcr( 1 ) == "JCR-1"
    ok: config.has_json() == true
    ok: config.json() == "JSON"
    ok: ! _CrtMemDifference( &s3, &s1, &s2 )

    GrammarSet TODOS [test-grammar-set.cpp:40]
    ==========================================
    ok: ! _CrtMemDifference( &s3, &s1, &s2 )

    ValueConstraint [test-low-level-objects.cpp:40]
    ===============================================
    ok: vc.is_set() == false
      : vc = "string"
    ok: vc.is_set() == true
    ok: vc.is_string() == true
    ok: vc.as_string() == "string"
    ok: vc.as_string() != "other"
    ok: vc.as_pattern() == "string"
    ok: vc.as_modifiers() == ""
    ok: vc.is_bool() == false
    ok: vc.is_int() == false
    ok: vc.is_uint() == false
    ok: vc.is_float() == false
      : vc = std::string( "string" )
    ok: vc.is_set() == true
    ok: vc.is_string() == true
    ok: vc.as_string() == "string"
    ok: vc.as_string() != "other"
    ok: vc.as_pattern() == "string"
    ok: vc.as_modifiers() == ""
    ok: vc.is_bool() == false
    ok: vc.is_int() == false
    ok: vc.is_uint() == false
    ok: vc.is_float() == false
      : vc = std::string( "/regex/" )
    ok: vc.is_set() == true
    ok: vc.is_string() == true
    ok: vc.as_string() == "/regex/"
    ok: vc.as_string() != "other"
    ok: vc.as_pattern() == "regex"
    ok: vc.as_modifiers() == ""
      : vc = std::string( "/regex/i" )
    ok: vc.is_set() == true
    ok: vc.is_string() == true
    ok: vc.as_string() == "/regex/i"
    ok: vc.as_string() != "other"
    ok: vc.as_pattern() == "regex"
    ok: vc.as_modifiers() == "i"
      : vc = true
    ok: vc.is_set() == true
    ok: vc.is_bool() == true
    ok: vc.as_bool() == true
    ok: vc.is_string() == false
    ok: vc.is_int() == false
    ok: vc.is_uint() == false
    ok: vc.is_float() == false
      : vc = false
    ok: vc.is_set() == true
    ok: vc.is_bool() == true
    ok: vc.as_bool() == false
    ok: vc.is_string() == false
    ok: vc.is_int() == false
    ok: vc.is_uint() == false
    ok: vc.is_float() == false
      : vc = (int64)10
    ok: vc.is_set() == true
    ok: vc.is_int() == true
    ok: vc.as_int() == 10
    ok: vc.is_string() == false
    ok: vc.is_bool() == false
    ok: vc.is_uint() == false
    ok: vc.is_float() == false
      : vc = (uint64)10
    ok: vc.is_set() == true
    ok: vc.is_uint() == true
    ok: vc.as_uint() == 10
    ok: vc.is_string() == false
    ok: vc.is_bool() == false
    ok: vc.is_int() == false
    ok: vc.is_float() == false
      : vc = 10.5
    ok: vc.is_set() == true
    ok: vc.is_float() == true
    ok: vc.as_float() == 10.5
    ok: vc.is_string() == false
    ok: vc.is_bool() == false
    ok: vc.is_int() == false
    ok: vc.is_uint() == false
      : vc = 2.5e+3
    ok: vc.is_set() == true
    ok: vc.is_float() == true
    ok: vc.as_float() == 2500.0
    ok: vc.is_string() == false
    ok: vc.is_bool() == false
    ok: vc.is_int() == false
    ok: vc.is_uint() == false
      : vc.clear()
    ok: vc.is_set() == false
    ok: vc.is_string() == false
    ok: vc.is_bool() == false
    ok: vc.is_int() == false
    ok: vc.is_uint() == false
    ok: vc.is_float() == false
    ok: ! _CrtMemDifference( &s3, &s1, &s2 )

    MemberName [test-low-level-objects.cpp:149]
    ===========================================
    ok: mn.is_absent() == true
    ok: mn.is_literal() == false
    ok: mn.is_regex() == false
    ok: mn.name() == ""
      : mn.set_literal( "foo" )
    ok: mn.is_absent() == false
    ok: mn.is_literal() == true
    ok: mn.is_regex() == false
    ok: mn.name() == "foo"
      : mn.set_regex( "/name*/i" )
    ok: mn.is_absent() == false
    ok: mn.is_literal() == false
    ok: mn.is_regex() == true
    ok: mn.name() == "/name*/i"
    ok: mn.pattern() == "name*"
    ok: mn.modifiers() == "i"
      : mn.set_regex( "//" )
    ok: mn.pattern() == ""
    ok: mn.modifiers() == ""
      : mn.set_absent()
    ok: mn.is_absent() == true
    ok: mn.is_literal() == false
    ok: mn.is_regex() == false
    ok: mn.name() == ""
      : mn.set_literal( "foo" )
    ok: mn.is_literal() == true
      : mn.clear()
    ok: mn.is_absent() == true
    ok: mn.is_literal() == false
    ok: mn.is_regex() == false
    ok: mn.name() == ""
    ok: ! _CrtMemDifference( &s3, &s1, &s2 )

    TargetRule [test-low-level-objects.cpp:191]
    ===========================================
    ok: ! tr.p_rule
    ok: ! _CrtMemDifference( &s3, &s1, &s2 )

    Rule [test-low-level-objects.cpp:198]
    =====================================
    ok: ! r.p_parent
    ok: r.type == Rule::NONE
      : Rule::uniq_ptr pu_rule( new Rule )
    ok: ! pu_rule->p_parent
    ok: pu_rule->type == Rule::NONE
      : Rule * p_new_rule = pu_rule.get()
      : Rule * p_appended_rule = r.append_child_rule( pu_rule )
    ok: p_appended_rule == p_new_rule
    ok: p_appended_rule->p_parent == &r
    ok: ! _CrtMemDifference( &s3, &s1, &s2 )

    Grammar [test-low-level-objects.cpp:216]
    ========================================
      #### Adding and accessing unaliased imports ####
      : g.add_unaliased_import( "foo" )
    ok: g.unaliased_imports.size() == 1
      : g.add_unaliased_import( "bar" )
    ok: g.unaliased_imports.size() == 2
    ok: g.unaliased_imports[0] == "foo"
    ok: g.unaliased_imports[1] == "bar"
      #### Adding aliased imports ####
    ok: g.has_aliased_import( "foo" ) == false
    ok: g.add_aliased_import( "foo", "http://foo" ) == true
    ok: g.has_aliased_import( "foo" ) == true
    ok: g.has_aliased_import( "bar" ) == false
    ok: g.add_aliased_import( "bar", "http://bar" ) == true
    ok: g.has_aliased_import( "bar" ) == true
    ok: g.aliased_imports["foo"] == "http://foo"
    ok: g.aliased_imports["bar"] == "http://bar"
      #### Adding duplicate aliased imports fails ####
    ok: g.add_aliased_import( "foo", "http://foo" ) == false
      #### Accessing aliased imports for const instances ####
      : const Grammar & r_g( g )
    ok: r_g.get_aliased_import( "foo" ).value() == "http://foo"
      : std::string foo = r_g.get_aliased_import( "foo" )
    ok: foo == "http://foo"
    ok: r_g.get_aliased_import( "bar" ).value() == "http://bar"
    ok: r_g.has_aliased_import( "blah" ) == false
    ok: r_g.get_aliased_import( "blah" ).is_found() == false
      #### Adding rules ####
    ok: g.rules.size() == 0
      : Rule::uniq_ptr pu_r( new Rule )
      : pu_r->p_parent = pu_r.get()
    ok: pu_r->p_parent != 0
      : Rule * p_unmanaged_rule = pu_r.get()
      : Rule * p_r = g.append_rule( pu_r )
    ok: p_r == p_unmanaged_rule
    ok: ! p_r->p_parent
    ok: g.rules.size() == 1
    ok: ! _CrtMemDifference( &s3, &s1, &s2 )

    ok: ! _CrtMemDifference( &s3, &s1, &s2 )

    Miscellaneous TODOs [test-main.cpp:37]
    ======================================
    ok: ! _CrtMemDifference( &s3, &s1, &s2 )

    GrammarParser - Syntax parsing with no semantic interpretation - comments [test-parsing-only.cpp:62]
    ====================================================================================================
      Calling: test_parsing_only( "" ) (65)
      ####  ####
    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "   " ) (67)
      ####     ####
    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "; Hello World" ) (69)
      #### ; Hello World ####
    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "; Hello World" ) (71)
      #### ; Hello World ####
    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "; Hello World\n" "     " ) (74)
      #### ; Hello World
      ####
    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "; Hello World\n" "     \n" "  ; Let's go..." ) (78)
      #### ; Hello World
     
  ; Let's go... ####
    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "; Hello World ; Let's go...\n" ) (80)
      #### ; Hello World ; Let's go...
 ####
    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "" ) (82)
      ####  ####
    ok: status == JCRParser::S_OK
    ok: ! _CrtMemDifference( &s3, &s1, &s2 )

    GrammarParser - Syntax parsing - JCR directive [test-parsing-only.cpp:85]
    =========================================================================
      Calling: test_parsing_only( "#jcr-version 0.9" ) (88)
      #### #jcr-version 0.9 ####
    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "#jcr-version 0.9 " ) (90)
      #### #jcr-version 0.9  ####
    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "#jcr-version 0.9 \t" ) (92)
      #### #jcr-version 0.9 	 ####
    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "#jcr-version 0.9 +co-constraints-1.0" ) (94)
      #### #jcr-version 0.9 +co-constraints-1.0 ####
    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "#jcr-version 0.9 + co-constraints-1.0" ) (96)
      #### #jcr-version 0.9 + co-constraints-1.0 ####
    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "#jcr-version 0.9 + co-constraints-1.0 + doc-0.9" ) (98)
      #### #jcr-version 0.9 + co-constraints-1.0 + doc-0.9 ####
    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "#{\n" "jcr-version\n" "0.9\n" "}" ) (103)
      #### #{
jcr-version
0.9
} ####
    ok: status == JCRParser::S_OK
      Calling: test_parsing_bad_input( "#\n" "jcr-version\n" " 0.9" ) (107)
      #### #
jcr-version
 0.9 ####
    ok: status != JCRParser::S_OK
      Calling: test_parsing_bad_input( "#jcr-version 0.12" ) (109)
      #### #jcr-version 0.12 ####
    ok: status != JCRParser::S_OK
      Calling: test_parsing_bad_input( "#jcr-version 10.5" ) (111)
      #### #jcr-version 10.5 ####
    ok: status != JCRParser::S_OK
      Calling: test_parsing_only( "; Start\n" "#jcr-version 0.9" ) (114)
      #### ; Start
#jcr-version 0.9 ####
    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "; Start\n" "#jcr-version 0.9\n" "; End" ) (118)
      #### ; Start
#jcr-version 0.9
; End ####
    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "  #jcr-version 0.9\n" "; End" ) (121)
      ####   #jcr-version 0.9
; End ####
    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "; Start ; #jcr-version 0.9" ) (123)
      #### ; Start ; #jcr-version 0.9 ####
    ok: status == JCRParser::S_OK
      Calling: test_parsing_bad_input( "#jcr-version0.5" ) (125)
      #### #jcr-version0.5 ####
    ok: status != JCRParser::S_OK
      Calling: test_parsing_bad_input( "#jcr-version a.5" ) (127)
      #### #jcr-version a.5 ####
    ok: status != JCRParser::S_OK
      Calling: test_parsing_bad_input( "#jcr-version 0:5" ) (129)
      #### #jcr-version 0:5 ####
    ok: status != JCRParser::S_OK
      Calling: test_parsing_bad_input( "#jcr-version 0.b" ) (131)
      #### #jcr-version 0.b ####
    ok: status != JCRParser::S_OK
    ok: ! _CrtMemDifference( &s3, &s1, &s2 )

    GrammarParser - Syntax parsing - ruleset-id directive [test-parsing-only.cpp:134]
    =================================================================================
      Calling: test_parsing_only( "#ruleset-id http://www.example.com/jcr\n" ) (137)
      #### #ruleset-id http://www.example.com/jcr
 ####
    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "#ruleset-id http://www.example.com/jcr \n" ) (139)
      #### #ruleset-id http://www.example.com/jcr 
 ####
    ok: status == JCRParser::S_OK
      Calling: test_parsing_bad_input( "#ruleset-id \n" ) (141)
      #### #ruleset-id 
 ####
    ok: status != JCRParser::S_OK
      Calling: test_parsing_bad_input( "#ruleset-id\n" ) (143)
      #### #ruleset-id
 ####
    ok: status != JCRParser::S_OK
      Calling: test_parsing_only( "; A comment ; #ruleset-id http://www.example.com/jcr\n" ) (145)
      #### ; A comment ; #ruleset-id http://www.example.com/jcr
 ####
    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "#ruleset-id http://www.example.com/jcr\n" "; A comment" ) (148)
      #### #ruleset-id http://www.example.com/jcr
; A comment ####
    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "#ruleset-id http://www.example.com/jcr\n" "; A comment\n" "; Another comment\n" "#jcr-version 0.9\n" ) (153)
      #### #ruleset-id http://www.example.com/jcr
; A comment
; Another comment
#jcr-version 0.9
 ####
    ok: status == JCRParser::S_OK
      : ParserHarness ph( "#ruleset-id http://www.example.com/jcr" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().ruleset_id == "http://www.example.com/jcr"
    ok: ! _CrtMemDifference( &s3, &s1, &s2 )

    GrammarParser - Syntax parsing - import directive [test-parsing-only.cpp:161]
    =============================================================================
      Calling: test_parsing_only( "#import http://www.example.com/jcr\n" ) (164)
      #### #import http://www.example.com/jcr
 ####
    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "#import http://www.example.com/jcr \n" ) (166)
      #### #import http://www.example.com/jcr 
 ####
    ok: status == JCRParser::S_OK
      Calling: test_parsing_bad_input( "#import http://www.example.com/jcr as\n" ) (168)
      #### #import http://www.example.com/jcr as
 ####
    ok: status != JCRParser::S_OK
      Calling: test_parsing_bad_input( "#import http://www.example.com/jcr as \n" ) (170)
      #### #import http://www.example.com/jcr as 
 ####
    ok: status != JCRParser::S_OK
      Calling: test_parsing_only( "#import http://www.example.com/jcr as my_1st-alias\n" ) (172)
      #### #import http://www.example.com/jcr as my_1st-alias
 ####
    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "#import http://www.example.com/jcr as my_1st-alias \n" ) (174)
      #### #import http://www.example.com/jcr as my_1st-alias 
 ####
    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( " ; Hello\n" "#import http://www.example.com/jcr as  my_1st-alias\n" ) (177)
      ####  ; Hello
#import http://www.example.com/jcr as  my_1st-alias
 ####
    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( " ; Hello\n" "#jcr-version 0.9\n" "#ruleset-id http://www.example.com/jcr\n" "#import http://www.example.com/jcr as  my_1st-alias\n" "#import http://www.example.com/jcr2 as  my_2nd-alias\n" "\n" ) (184)
      ####  ; Hello
#jcr-version 0.9
#ruleset-id http://www.example.com/jcr
#import http://www.example.com/jcr as  my_1st-alias
#import http://www.example.com/jcr2 as  my_2nd-alias

 ####
    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( " ; Hello\n" "#jcr-version 0.9\n" "  ; A comment\n" "#ruleset-id http://www.example.com/jcr\n" "  ; A comment\n" "  ; A comment\n" "#import http://www.example.com/jcr as  my_1st-alias\n" "  ; A comment\n" "  ; A comment\n" "  ; A comment\n" "  ; A comment\n" "#import http://www.example.com/jcr2 as  my_2nd-alias\n" "\n" ) (198)
      ####  ; Hello
#jcr-version 0.9
  ; A comment
#ruleset-id http://www.example.com/jcr
  ; A comment
  ; A comment
#import http://www.example.com/jcr as  my_1st-alias
  ; A comment
  ; A comment
  ; A comment
  ; A comment
#import http://www.example.com/jcr2 as  my_2nd-alias

 ####
    ok: status == JCRParser::S_OK
      : ParserHarness ph( "#import http://www.example.com/jcr" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().unaliased_imports[0] == "http://www.example.com/jcr"
      : ParserHarness ph( "#import http://www.example.com/jcr as jcr" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().has_aliased_import( "jcr" )
    ok: ph.grammar().get_aliased_import( "jcr" ).value() == "http://www.example.com/jcr"
    ok: ! _CrtMemDifference( &s3, &s1, &s2 )

    GrammarParser - Syntax parsing - multi-line directive [test-parsing-only.cpp:212]
    =================================================================================
      Calling: test_parsing_only( "#{constraint foo \n" "  $id == 'None' }\n" ) (216)
      #### #{constraint foo 
  $id == 'None' }
 ####
    ok: status == JCRParser::S_OK
      : ParserHarness ph( "#{constraint foo\n" "    $name == /p\\d{1,5}/ && ; Must allow } and { in comments\n" "    $when == \"} with {\"\n" "}\n" "$my_rule = $other_rule\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ! _CrtMemDifference( &s3, &s1, &s2 )

    GrammarParser - Syntax parsing - TBD directive [test-parsing-only.cpp:230]
    ==========================================================================
      Calling: test_parsing_only( "#TBD\n" ) (233)
      #### #TBD
 ####
    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "#TBD  we\n" ) (235)
      #### #TBD  we
 ####
    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "#TBD  we don't know\n" ) (237)
      #### #TBD  we don't know
 ####
    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "; Hello\n" "#TBD\n" "#jcr-version 0.9\n" ) (241)
      #### ; Hello
#TBD
#jcr-version 0.9
 ####
    ok: status == JCRParser::S_OK
    ok: ! _CrtMemDifference( &s3, &s1, &s2 )

    GrammarParser - Syntax parsing - target_rule_name [test-parsing-only.cpp:244]
    =============================================================================
      : ParserHarness ph( "$my_rule = $other_rule\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::TARGET_RULE
    ok: ph.grammar().rules[0].target_rule.local_name == "other_rule"
      : ParserHarness ph( "#import http://foo.bar as foo\n $my_rule = $foo.other_rule\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::TARGET_RULE
    ok: ph.grammar().rules[0].target_rule.rulesetid == "http://foo.bar"
    ok: ph.grammar().rules[0].target_rule.local_name == "other_rule"
      Calling: test_parsing_only( "$my_rule = @{not} $other_rule\n" ) (264)
      #### $my_rule = @{not} $other_rule
 ####
    ok: status == JCRParser::S_OK
    ok: ! _CrtMemDifference( &s3, &s1, &s2 )

    GrammarParser - Syntax parsing - Primitive rules [test-parsing-only.cpp:267]
    ============================================================================
      : ParserHarness ph( "$my_rule = : flubber\n" )
    ok: ph.status() != JCRParser::S_OK
      : ParserHarness ph( "$my_rule = : null\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::TNULL
    ok: ph.grammar().rules[0].repetition.min == 1
    ok: ph.grammar().rules[0].repetition.max == 1
      : ParserHarness ph( "$my_rule = :null\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::TNULL
    ok: ph.grammar().rules[0].repetition.min == 1
    ok: ph.grammar().rules[0].repetition.max == 1
      : ParserHarness ph( "$my_rule =: null\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::TNULL
    ok: ph.grammar().rules[0].repetition.min == 1
    ok: ph.grammar().rules[0].repetition.max == 1
      : ParserHarness ph( "$my_rule =:null\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::TNULL
    ok: ph.grammar().rules[0].repetition.min == 1
    ok: ph.grammar().rules[0].repetition.max == 1
      : ParserHarness ph( "$my_rule= : null\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::TNULL
    ok: ph.grammar().rules[0].repetition.min == 1
    ok: ph.grammar().rules[0].repetition.max == 1
      : ParserHarness ph( "$my_rule= :null\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::TNULL
    ok: ph.grammar().rules[0].repetition.min == 1
    ok: ph.grammar().rules[0].repetition.max == 1
      : ParserHarness ph( "$my_rule=: null\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::TNULL
    ok: ph.grammar().rules[0].repetition.min == 1
    ok: ph.grammar().rules[0].repetition.max == 1
      : ParserHarness ph( "$my_rule=:null\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::TNULL
    ok: ph.grammar().rules[0].repetition.min == 1
    ok: ph.grammar().rules[0].repetition.max == 1
      : ParserHarness ph( "$my_rule=null\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::TNULL
    ok: ph.grammar().rules[0].repetition.min == 1
    ok: ph.grammar().rules[0].repetition.max == 1
      : ParserHarness ph( "$my_rule= null\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::TNULL
    ok: ph.grammar().rules[0].repetition.min == 1
    ok: ph.grammar().rules[0].repetition.max == 1
      : ParserHarness ph( "$my_rule = null\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::TNULL
    ok: ph.grammar().rules[0].repetition.min == 1
    ok: ph.grammar().rules[0].repetition.max == 1
      : ParserHarness ph( "$my_rule =null\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::TNULL
    ok: ph.grammar().rules[0].repetition.min == 1
    ok: ph.grammar().rules[0].repetition.max == 1
      : ParserHarness ph( "$another_rule= : boolean\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "another_rule"
    ok: ph.grammar().rules[0].type == Rule::BOOLEAN
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "$another_rule = : true\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "another_rule"
    ok: ph.grammar().rules[0].type == Rule::BOOLEAN
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min.is_bool() == true
    ok: ph.grammar().rules[0].min.as_bool() == true
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.is_bool() == true
    ok: ph.grammar().rules[0].max.as_bool() == true
      : ParserHarness ph( "$another_rule = : false\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "another_rule"
    ok: ph.grammar().rules[0].type == Rule::BOOLEAN
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min.is_bool() == true
    ok: ph.grammar().rules[0].min.as_bool() == false
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.is_bool() == true
    ok: ph.grammar().rules[0].max.as_bool() == false
      : ParserHarness ph( "$rule-2 = : string\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::STRING_TYPE
      : ParserHarness ph( "$rule-2 = : \"a string\"\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::STRING_LITERAL
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min.is_string() == true
    ok: ph.grammar().rules[0].min.as_string() == "a string"
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.is_string() == true
    ok: ph.grammar().rules[0].max.as_string() == "a string"
      : ParserHarness ph( "$rule-2 = \"a string\"\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::STRING_LITERAL
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min.is_string() == true
    ok: ph.grammar().rules[0].min.as_string() == "a string"
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.is_string() == true
    ok: ph.grammar().rules[0].max.as_string() == "a string"
      : ParserHarness ph( "$rule-2 = : /pref\\d+/i\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::STRING_REGEX
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min.is_string() == true
    ok: ph.grammar().rules[0].min.as_string() == "/pref\\d+/i"
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.is_string() == true
    ok: ph.grammar().rules[0].max.as_string() == "/pref\\d+/i"
      : ParserHarness ph( "$rule-2 = /pref\\d+/i\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::STRING_REGEX
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min.is_string() == true
    ok: ph.grammar().rules[0].min.as_string() == "/pref\\d+/i"
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.is_string() == true
    ok: ph.grammar().rules[0].max.as_string() == "/pref\\d+/i"
      : ParserHarness ph( "$rule-2 = /pref\\/d/i\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::STRING_REGEX
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min.is_string() == true
    ok: ph.grammar().rules[0].min.as_string() == "/pref\\/d/i"
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.is_string() == true
    ok: ph.grammar().rules[0].max.as_string() == "/pref\\/d/i"
      : ParserHarness ph( "$rule-2 = : float\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::FLOAT
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "$rule-2 = float\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::FLOAT
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "$rule-2 = : double\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::DOUBLE
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "$rule-2 = double\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::DOUBLE
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "$rule-2 = : 1.0..\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::DOUBLE
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min.is_float() == true
    ok: ph.grammar().rules[0].min.as_float() == 1.0
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "$rule-2 = 1.0..\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::DOUBLE
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min.is_float() == true
    ok: ph.grammar().rules[0].min.as_float() == 1.0
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "$rule-2 = : -1.0..3.5e-2\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::DOUBLE
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min.is_float() == true
    ok: ph.grammar().rules[0].min.as_float() == -1.0
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.is_float() == true
    ok: ph.grammar().rules[0].max.as_float() == 3.5e-2
      : ParserHarness ph( "$rule-2 = -1.0..3.5e-2\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::DOUBLE
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min.is_float() == true
    ok: ph.grammar().rules[0].min.as_float() == -1.0
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.is_float() == true
    ok: ph.grammar().rules[0].max.as_float() == 3.5e-2
      : ParserHarness ph( "$rule-2 = : -1.0..-3.5e-2\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::DOUBLE
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min.is_float() == true
    ok: ph.grammar().rules[0].min.as_float() == -1.0
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.is_float() == true
    ok: ph.grammar().rules[0].max.as_float() == -3.5e-2
      : ParserHarness ph( "$rule-2 = -1.0..-3.5e-2\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::DOUBLE
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min.is_float() == true
    ok: ph.grammar().rules[0].min.as_float() == -1.0
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.is_float() == true
    ok: ph.grammar().rules[0].max.as_float() == -3.5e-2
      : ParserHarness ph( "$rule-2 = : ..-3.5e-2\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::DOUBLE
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.is_float() == true
    ok: ph.grammar().rules[0].max.as_float() == -3.5e-2
      : ParserHarness ph( "$rule-2 = ..-3.5e-2\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::DOUBLE
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.is_float() == true
    ok: ph.grammar().rules[0].max.as_float() == -3.5e-2
      : ParserHarness ph( "$rule-2 = : 4.0\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::DOUBLE
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min.is_float() == true
    ok: ph.grammar().rules[0].min.as_float() == 4.0
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.is_float() == true
    ok: ph.grammar().rules[0].max.as_float() == 4.0
      : ParserHarness ph( "$rule-2 = 4.0\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::DOUBLE
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min.is_float() == true
    ok: ph.grammar().rules[0].min.as_float() == 4.0
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.is_float() == true
    ok: ph.grammar().rules[0].max.as_float() == 4.0
      : ParserHarness ph( "$rule-2 = : -3.5e-2\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::DOUBLE
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min.is_float() == true
    ok: ph.grammar().rules[0].min.as_float() == -3.5e-2
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.is_float() == true
    ok: ph.grammar().rules[0].max.as_float() == -3.5e-2
      : ParserHarness ph( "$rule-2 = -3.5e-2\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::DOUBLE
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min.is_float() == true
    ok: ph.grammar().rules[0].min.as_float() == -3.5e-2
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.is_float() == true
    ok: ph.grammar().rules[0].max.as_float() == -3.5e-2
      : ParserHarness ph( "$rule-2 = : integer\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "$rule-2 = integer\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "$rule-2 = : 100..\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::UINTEGER
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min.is_uint() == true
    ok: ph.grammar().rules[0].min.as_uint() == 100
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "$rule-2 = 100..\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::UINTEGER
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min.is_uint() == true
    ok: ph.grammar().rules[0].min.as_uint() == 100
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "$rule-2 = : -100..-50\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min.is_int() == true
    ok: ph.grammar().rules[0].min.as_int() == -100
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.is_int() == true
    ok: ph.grammar().rules[0].max.as_int() == -50
      : ParserHarness ph( "$rule-2 = -100..-50\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min.is_int() == true
    ok: ph.grammar().rules[0].min.as_int() == -100
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.is_int() == true
    ok: ph.grammar().rules[0].max.as_int() == -50
      : ParserHarness ph( "$rule-2 = : ..50\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.is_int() == true
    ok: ph.grammar().rules[0].max.as_int() == 50
      : ParserHarness ph( "$rule-2 = ..50\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.is_int() == true
    ok: ph.grammar().rules[0].max.as_int() == 50
      : ParserHarness ph( "$rule-2 = : 64\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::UINTEGER
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min.is_uint() == true
    ok: ph.grammar().rules[0].min.as_uint() == 64
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.is_uint() == true
    ok: ph.grammar().rules[0].max.as_uint() == 64
      : ParserHarness ph( "$rule-2 = 64\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::UINTEGER
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min.is_uint() == true
    ok: ph.grammar().rules[0].min.as_uint() == 64
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.is_uint() == true
    ok: ph.grammar().rules[0].max.as_uint() == 64
      : ParserHarness ph( "$rule-2 = : uint8\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::UINTEGER
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min.is_uint() == true
    ok: ph.grammar().rules[0].min.as_uint() == 0
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.is_uint() == true
    ok: ph.grammar().rules[0].max.as_uint() == 255
      : ParserHarness ph( "$rule-2 = uint8\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::UINTEGER
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min.is_uint() == true
    ok: ph.grammar().rules[0].min.as_uint() == 0
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.is_uint() == true
    ok: ph.grammar().rules[0].max.as_uint() == 255
      : ParserHarness ph( "$rule-2 = : int8\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min.is_int() == true
    ok: ph.grammar().rules[0].min.as_int() == -128
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.is_int() == true
    ok: ph.grammar().rules[0].max.as_int() == 127
      : ParserHarness ph( "$rule-2 = int8\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min.is_int() == true
    ok: ph.grammar().rules[0].min.as_int() == -128
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.is_int() == true
    ok: ph.grammar().rules[0].max.as_int() == 127
      : ParserHarness ph( "$rule-2 = : uint32\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].type == Rule::UINTEGER
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min.is_uint() == true
    ok: ph.grammar().rules[0].min.as_uint() == 0
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.is_uint() == true
    ok: ph.grammar().rules[0].max.as_uint() == 4294967295
      : ParserHarness ph( "$rule-2 = uint32\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].type == Rule::UINTEGER
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min.is_uint() == true
    ok: ph.grammar().rules[0].min.as_uint() == 0
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.is_uint() == true
    ok: ph.grammar().rules[0].max.as_uint() == 4294967295
      : ParserHarness ph( "$rule-2 = : int32\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min.is_int() == true
    ok: ph.grammar().rules[0].min.as_int() == -2147483648LL
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.is_int() == true
    ok: ph.grammar().rules[0].max.as_int() == 2147483647
      : ParserHarness ph( "$rule-2 = int32\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min.is_int() == true
    ok: ph.grammar().rules[0].min.as_int() == -2147483648LL
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.is_int() == true
    ok: ph.grammar().rules[0].max.as_int() == 2147483647
      : ParserHarness ph( "$rule-2 = : uint64\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].type == Rule::UINTEGER
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min.is_uint() == true
    ok: ph.grammar().rules[0].min.as_uint() == 0
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.is_uint() == true
    ok: ph.grammar().rules[0].max.as_uint() == 18446744073709551615
      : ParserHarness ph( "$rule-2 = uint64\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].type == Rule::UINTEGER
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min.is_uint() == true
    ok: ph.grammar().rules[0].min.as_uint() == 0
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.is_uint() == true
    ok: ph.grammar().rules[0].max.as_uint() == 18446744073709551615
      : ParserHarness ph( "$rule-2 = : int64\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min.is_int() == true
    ok: ph.grammar().rules[0].min.as_int() == -9223372036854775808LL
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.is_int() == true
    ok: ph.grammar().rules[0].max.as_int() == 9223372036854775807
      : ParserHarness ph( "$rule-2 = int64\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min.is_int() == true
    ok: ph.grammar().rules[0].min.as_int() == -9223372036854775808LL
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.is_int() == true
    ok: ph.grammar().rules[0].max.as_int() == 9223372036854775807
      : ParserHarness ph( "$rule-2 = : ipv4\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::IPV4
      : ParserHarness ph( "$rule-2 = ipv4\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::IPV4
      : ParserHarness ph( "$rule-2 = : ipv6\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::IPV6
      : ParserHarness ph( "$rule-2 = ipv6\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::IPV6
      : ParserHarness ph( "$rule-2 = : ipaddr\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::IPADDR
      : ParserHarness ph( "$rule-2 = ipaddr\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::IPADDR
      : ParserHarness ph( "$rule-2 = : idn\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::IDN
      : ParserHarness ph( "$rule-2 = idn\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::IDN
      : ParserHarness ph( "$rule-2 = : fqdn\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::FQDN
      : ParserHarness ph( "$rule-2 = fqdn\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::FQDN
      : ParserHarness ph( "$rule-2 = : uri..http\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::URI_RANGE
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min.is_string() == true
    ok: ph.grammar().rules[0].min.as_string() == "http"
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.is_string() == true
    ok: ph.grammar().rules[0].max.as_string() == "http"
      : ParserHarness ph( "$rule-2 = uri..http\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::URI_RANGE
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min.is_string() == true
    ok: ph.grammar().rules[0].min.as_string() == "http"
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.is_string() == true
    ok: ph.grammar().rules[0].max.as_string() == "http"
      : ParserHarness ph( "$rule-2 = : uri..sip" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::URI_RANGE
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min.is_string() == true
    ok: ph.grammar().rules[0].min.as_string() == "sip"
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.is_string() == true
    ok: ph.grammar().rules[0].max.as_string() == "sip"
      : ParserHarness ph( "$rule-2 = uri..sip" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::URI_RANGE
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min.is_string() == true
    ok: ph.grammar().rules[0].min.as_string() == "sip"
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.is_string() == true
    ok: ph.grammar().rules[0].max.as_string() == "sip"
      : ParserHarness ph( "$rule-2 = : uri\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::URI_TYPE
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "$rule-2 = uri\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::URI_TYPE
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "$rule-2 = : phone\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::PHONE
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "$rule-2 = phone\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::PHONE
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "$rule-2 = : email\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::EMAIL
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "$rule-2 = email\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::EMAIL
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "$rule-2 = : date\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::DATE
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "$rule-2 = date\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::DATE
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "$rule-2 = : time\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::TIME
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "$rule-2 = time\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::TIME
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "$rule-2 = : datetime\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::DATETIME
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "$rule-2 = datetime\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::DATETIME
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "$rule-2 = : hex\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::HEX
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "$rule-2 = hex\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::HEX
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "$rule-2 = : base32\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::BASE32
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "$rule-2 = base32\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::BASE32
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "$rule-2 = : base32hex\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::BASE32HEX
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "$rule-2 = base32hex\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::BASE32HEX
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "$rule-2 = : base64\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::BASE64
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "$rule-2 = base64\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::BASE64
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "$rule-2 = : base64url\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::BASE64URL
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "$rule-2 = base64url\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::BASE64URL
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "$rule-2 = : any\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::ANY
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "$rule-2 = any\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::ANY
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "$my_rule = : @{root} null\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].annotations.is_root == true
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::TNULL
      : ParserHarness ph( "$my_rule = @{root} null\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].annotations.is_root == true
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::TNULL
    ok: ! _CrtMemDifference( &s3, &s1, &s2 )

    GrammarParser - Syntax parsing - root rule [test-parsing-only.cpp:1377]
    =======================================================================
      : ParserHarness ph( " integer" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == ""
    ok: ph.grammar().rules[0].annotations.is_root == true
    ok: ph.grammar().rules[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].repetition.min == 1
    ok: ph.grammar().rules[0].repetition.max == 1
      : ParserHarness ph( "integer \n $my_rule=: null\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 2
    ok: ph.grammar().rules[0].rule_name == ""
    ok: ph.grammar().rules[0].type == Rule::INTEGER
    ok: ph.grammar().rules[1].rule_name == "my_rule"
    ok: ph.grammar().rules[1].type == Rule::TNULL
      : ParserHarness ph( "#ruleset-id http://example.com/jcr\n integer \n $my_rule = : null\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().ruleset_id == "http://example.com/jcr"
    ok: ph.grammar().rules.size() == 2
    ok: ph.grammar().rules[0].rule_name == ""
    ok: ph.grammar().rules[0].type == Rule::INTEGER
    ok: ph.grammar().rules[1].rule_name == "my_rule"
    ok: ph.grammar().rules[1].type == Rule::TNULL
      : ParserHarness ph( " {}" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == ""
    ok: ph.grammar().rules[0].annotations.is_root == true
    ok: ph.grammar().rules[0].type == Rule::OBJECT
    ok: ph.grammar().rules[0].repetition.min == 1
    ok: ph.grammar().rules[0].repetition.max == 1
      : ParserHarness ph( "{ \"an-int\" : integer }" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == ""
    ok: ph.grammar().rules[0].annotations.is_root == true
    ok: ph.grammar().rules[0].type == Rule::OBJECT
    ok: ph.grammar().rules[0].repetition.min == 1
    ok: ph.grammar().rules[0].repetition.max == 1
      : ParserHarness ph( " [   ]" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == ""
    ok: ph.grammar().rules[0].annotations.is_root == true
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].repetition.min == 1
    ok: ph.grammar().rules[0].repetition.max == 1
      Calling: test_parsing_bad_input( ": junk\n" ) (1443)
      #### : junk
 ####
    ok: status != JCRParser::S_OK
      Calling: test_parsing_bad_input( "* junk\n" ) (1445)
      #### * junk
 ####
    ok: status != JCRParser::S_OK
    ok: ! _CrtMemDifference( &s3, &s1, &s2 )

    GrammarParser - Syntax parsing - Member name [test-parsing-only.cpp:1448]
    =========================================================================
      : ParserHarness ph( "$my_rule = \"Fred\" : null\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].member_name.is_literal() == true
    ok: ph.grammar().rules[0].member_name.name() == "Fred"
    ok: ph.grammar().rules[0].type == Rule::TNULL
      : ParserHarness ph( "$my_rule = /p_ref\\d+/ : null\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].member_name.is_regex() == true
    ok: ph.grammar().rules[0].member_name.name() == "/p_ref\\d+/"
    ok: ph.grammar().rules[0].type == Rule::TNULL
      : ParserHarness ph( "$my_rule = /p_ref\\d+/ : $my_type\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].member_name.is_regex() == true
    ok: ph.grammar().rules[0].member_name.name() == "/p_ref\\d+/"
    ok: ph.grammar().rules[0].type == Rule::TARGET_RULE
    ok: ph.grammar().rules[0].target_rule.local_name == "my_type"
      : ParserHarness ph( "$my_rule = \"abc\xE0\xAC\x8Bz\" : null\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].member_name.is_literal() == true
    ok: ph.grammar().rules[0].member_name.name() == "abc\xE0\xAC\x8Bz"
    ok: ph.grammar().rules[0].type == Rule::TNULL
      : ParserHarness ph( "$my_rule = \"X\\u0802A\" : null\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].member_name.is_literal() == true
    ok: ph.grammar().rules[0].member_name.name() == "X\xE0\xA0\x82""A"
    ok: ph.grammar().rules[0].type == Rule::TNULL
      : ParserHarness ph( "$my_rule = \"abc\\uD808\\uDF45=Ra\" : null\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].member_name.is_literal() == true
    ok: ph.grammar().rules[0].member_name.name() == "abc\xF0\x92\x8D\x85=Ra"
    ok: ph.grammar().rules[0].type == Rule::TNULL
      Calling: test_parsing_bad_input( "$my_rule = /p_ref\\d+/ * integer\n" ) (1507)
      #### $my_rule = /p_ref\d+/ * integer
 ####
    ok: status != JCRParser::S_OK
    ok: ! _CrtMemDifference( &s3, &s1, &s2 )

    GrammarParser - Syntax parsing - type-choice [test-parsing-only.cpp:1510]
    =========================================================================
      : ParserHarness ph( "$my_rule = : (null)\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::TYPE_CHOICE
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].rule_name == ""
    ok: ph.grammar().rules[0].children[0].type == Rule::TNULL
      : ParserHarness ph( "$my_rule = : ( null | integer )\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::TYPE_CHOICE
    ok: ph.grammar().rules[0].children.size() == 2
    ok: ph.grammar().rules[0].children[0].rule_name == ""
    ok: ph.grammar().rules[0].children[0].type == Rule::TNULL
    ok: ph.grammar().rules[0].children[1].type == Rule::INTEGER
      : ParserHarness ph( "$my_rule = : ( null | integer |\"my string\" )\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::TYPE_CHOICE
    ok: ph.grammar().rules[0].children.size() == 3
    ok: ph.grammar().rules[0].children[0].rule_name == ""
    ok: ph.grammar().rules[0].children[0].type == Rule::TNULL
    ok: ph.grammar().rules[0].children[1].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[2].type == Rule::STRING_LITERAL
    ok: ph.grammar().rules[0].children[2].min.is_string() == true
    ok: ph.grammar().rules[0].children[2].min.as_string() == "my string"
      : ParserHarness ph( "$my_rule = : ( null | (integer|float ) | \"my string\" )\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::TYPE_CHOICE
    ok: ph.grammar().rules[0].children.size() == 3
    ok: ph.grammar().rules[0].children[0].rule_name == ""
    ok: ph.grammar().rules[0].children[0].type == Rule::TNULL
    ok: ph.grammar().rules[0].children[1].type == Rule::TYPE_CHOICE
    ok: ph.grammar().rules[0].children[1].children.size() == 2
    ok: ph.grammar().rules[0].children[1].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[1].children[1].type == Rule::FLOAT
    ok: ph.grammar().rules[0].children[2].type == Rule::STRING_LITERAL
    ok: ph.grammar().rules[0].children[2].min.is_string() == true
    ok: ph.grammar().rules[0].children[2].min.as_string() == "my string"
      : ParserHarness ph( "#import http://common.com as common \n $my_rule =: ( null | $common.my_type )\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::TYPE_CHOICE
    ok: ph.grammar().rules[0].children.size() == 2
    ok: ph.grammar().rules[0].children[0].type == Rule::TNULL
    ok: ph.grammar().rules[0].children[1].type == Rule::TARGET_RULE
    ok: ph.grammar().rules[0].children[1].target_rule.rulesetid == "http://common.com"
    ok: ph.grammar().rules[0].children[1].target_rule.local_name == "my_type"
      : ParserHarness ph( "$my_rule = : @{not} ( null | integer )\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::TYPE_CHOICE
    ok: ph.grammar().rules[0].annotations.is_not == true
    ok: ph.grammar().rules[0].children.size() == 2
    ok: ph.grammar().rules[0].children[0].rule_name == ""
    ok: ph.grammar().rules[0].children[0].type == Rule::TNULL
    ok: ph.grammar().rules[0].children[1].type == Rule::INTEGER
      Calling: test_parsing_bad_input( "$my_rule = : ( )\n" ) (1595)
      #### $my_rule = : ( )
 ####
    ok: status != JCRParser::S_OK
      Calling: test_parsing_bad_input( "$my_rule = : ( | )\n" ) (1597)
      #### $my_rule = : ( | )
 ####
    ok: status != JCRParser::S_OK
      Calling: test_parsing_bad_input( "$my_rule = : ( integer | )\n" ) (1599)
      #### $my_rule = : ( integer | )
 ####
    ok: status != JCRParser::S_OK
      Calling: test_parsing_bad_input( "$my_rule = : ( integer * )\n" ) (1601)
      #### $my_rule = : ( integer * )
 ####
    ok: status != JCRParser::S_OK
      Calling: test_parsing_bad_input( "$my_rule = : ( integer : null )\n" ) (1603)
      #### $my_rule = : ( integer : null )
 ####
    ok: status != JCRParser::S_OK
    ok: ! _CrtMemDifference( &s3, &s1, &s2 )

    GrammarParser - Syntax parsing - object [test-parsing-only.cpp:1606]
    ====================================================================
      : ParserHarness ph( "$my_rule = { \"member\" : integer }\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::OBJECT
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].rule_name == ""
    ok: ph.grammar().rules[0].children[0].member_name.is_literal()
    ok: ph.grammar().rules[0].children[0].member_name.name() == "member"
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].repetition.min == 1
    ok: ph.grammar().rules[0].children[0].repetition.max == 1
      : ParserHarness ph( "$my_rule = :{ \"member\" : integer }\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::OBJECT
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].rule_name == ""
    ok: ph.grammar().rules[0].children[0].member_name.is_literal()
    ok: ph.grammar().rules[0].children[0].member_name.name() == "member"
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].repetition.min == 1
    ok: ph.grammar().rules[0].children[0].repetition.max == 1
      : ParserHarness ph( "$my_rule = { \"int-member\" : integer , \"string-member\" : string }\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::OBJECT
    ok: ph.grammar().rules[0].child_combiner == Rule::Sequence
    ok: ph.grammar().rules[0].children.size() == 2
    ok: ph.grammar().rules[0].children[0].member_name.is_literal()
    ok: ph.grammar().rules[0].children[0].member_name.name() == "int-member"
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].repetition.min == 1
    ok: ph.grammar().rules[0].children[0].repetition.max == 1
    ok: ph.grammar().rules[0].children[1].member_name.is_literal()
    ok: ph.grammar().rules[0].children[1].member_name.name() == "string-member"
    ok: ph.grammar().rules[0].children[1].type == Rule::STRING_TYPE
    ok: ph.grammar().rules[0].children[1].repetition.min == 1
    ok: ph.grammar().rules[0].children[1].repetition.max == 1
      : ParserHarness ph( "$my_rule = { \"int-member\" : integer | \"string-member\" : string }\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::OBJECT
    ok: ph.grammar().rules[0].child_combiner == Rule::Choice
    ok: ph.grammar().rules[0].children.size() == 2
    ok: ph.grammar().rules[0].children[0].member_name.is_literal()
    ok: ph.grammar().rules[0].children[0].member_name.name() == "int-member"
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].repetition.min == 1
    ok: ph.grammar().rules[0].children[0].repetition.max == 1
    ok: ph.grammar().rules[0].children[1].member_name.is_literal()
    ok: ph.grammar().rules[0].children[1].member_name.name() == "string-member"
    ok: ph.grammar().rules[0].children[1].type == Rule::STRING_TYPE
    ok: ph.grammar().rules[0].children[1].repetition.min == 1
    ok: ph.grammar().rules[0].children[1].repetition.max == 1
      : ParserHarness ph( "$my_rule = { \"int-member\" : integer , $other-rule }\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::OBJECT
    ok: ph.grammar().rules[0].child_combiner == Rule::Sequence
    ok: ph.grammar().rules[0].children.size() == 2
    ok: ph.grammar().rules[0].children[0].member_name.is_literal()
    ok: ph.grammar().rules[0].children[0].member_name.name() == "int-member"
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].repetition.min == 1
    ok: ph.grammar().rules[0].children[0].repetition.max == 1
    ok: ph.grammar().rules[0].children[1].member_name.is_absent()
    ok: ph.grammar().rules[0].children[1].type == Rule::TARGET_RULE
    ok: ph.grammar().rules[0].children[1].target_rule.local_name == "other-rule"
    ok: ph.grammar().rules[0].children[1].target_rule.rulesetid == ""
    ok: ph.grammar().rules[0].children[1].target_rule.p_rule == 0
    ok: ph.grammar().rules[0].children[1].repetition.min == 1
    ok: ph.grammar().rules[0].children[1].repetition.max == 1
      : ParserHarness ph( "$my_rule = { \"member\" : integer ? }\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::OBJECT
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].rule_name == ""
    ok: ph.grammar().rules[0].children[0].member_name.is_literal()
    ok: ph.grammar().rules[0].children[0].member_name.name() == "member"
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].repetition.min == 0
    ok: ph.grammar().rules[0].children[0].repetition.max == 1
      : ParserHarness ph( "$my_rule = { \"member\" : integer *0..1 }\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::OBJECT
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].rule_name == ""
    ok: ph.grammar().rules[0].children[0].member_name.is_literal()
    ok: ph.grammar().rules[0].children[0].member_name.name() == "member"
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].repetition.min == 0
    ok: ph.grammar().rules[0].children[0].repetition.max == 1
      : ParserHarness ph( "$my_rule = { /p-\\d+/ : integer + }\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::OBJECT
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].rule_name == ""
    ok: ph.grammar().rules[0].children[0].member_name.is_regex()
    ok: ph.grammar().rules[0].children[0].member_name.name() == "/p-\\d+/"
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].repetition.min == 1
    ok: ph.grammar().rules[0].children[0].repetition.max == -1
      : ParserHarness ph( "$my_rule ={/p-\\d+/:integer*5..}\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::OBJECT
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].rule_name == ""
    ok: ph.grammar().rules[0].children[0].member_name.is_regex()
    ok: ph.grammar().rules[0].children[0].member_name.name() == "/p-\\d+/"
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].repetition.min == 5
    ok: ph.grammar().rules[0].children[0].repetition.max == -1
      : ParserHarness ph( "$my_rule ={/p-\\d+/:integer*5..12}\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::OBJECT
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].rule_name == ""
    ok: ph.grammar().rules[0].children[0].member_name.is_regex()
    ok: ph.grammar().rules[0].children[0].member_name.name() == "/p-\\d+/"
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].repetition.min == 5
    ok: ph.grammar().rules[0].children[0].repetition.max == 12
      : ParserHarness ph( "$my_rule = { ( \"int-member\" : integer , \"string-member\" : string )? }\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::OBJECT
    ok: ph.grammar().rules[0].child_combiner == Rule::None
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].type == Rule::OBJECT_GROUP
    ok: ph.grammar().rules[0].children[0].repetition.min == 0
    ok: ph.grammar().rules[0].children[0].repetition.max == 1
    ok: ph.grammar().rules[0].children[0].children.size() == 2
    ok: ph.grammar().rules[0].children[0].child_combiner == Rule::Sequence
    ok: ph.grammar().rules[0].children[0].children[0].member_name.is_literal()
    ok: ph.grammar().rules[0].children[0].children[0].member_name.name() == "int-member"
    ok: ph.grammar().rules[0].children[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].children[0].repetition.min == 1
    ok: ph.grammar().rules[0].children[0].children[0].repetition.max == 1
    ok: ph.grammar().rules[0].children[0].children[1].member_name.is_literal()
    ok: ph.grammar().rules[0].children[0].children[1].member_name.name() == "string-member"
    ok: ph.grammar().rules[0].children[0].children[1].type == Rule::STRING_TYPE
    ok: ph.grammar().rules[0].children[0].children[1].repetition.min == 1
    ok: ph.grammar().rules[0].children[0].children[1].repetition.max == 1
      : ParserHarness ph( "$my_rule = { @{not} ( \"int-member\" : integer , \"string-member\" : string )? }\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::OBJECT
    ok: ph.grammar().rules[0].child_combiner == Rule::None
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].type == Rule::OBJECT_GROUP
    ok: ph.grammar().rules[0].children[0].annotations.is_not == true
    ok: ph.grammar().rules[0].children[0].repetition.min == 0
    ok: ph.grammar().rules[0].children[0].repetition.max == 1
    ok: ph.grammar().rules[0].children[0].children.size() == 2
    ok: ph.grammar().rules[0].children[0].child_combiner == Rule::Sequence
    ok: ph.grammar().rules[0].children[0].children[0].member_name.is_literal()
    ok: ph.grammar().rules[0].children[0].children[0].member_name.name() == "int-member"
    ok: ph.grammar().rules[0].children[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].children[0].repetition.min == 1
    ok: ph.grammar().rules[0].children[0].children[0].repetition.max == 1
    ok: ph.grammar().rules[0].children[0].children[1].member_name.is_literal()
    ok: ph.grammar().rules[0].children[0].children[1].member_name.name() == "string-member"
    ok: ph.grammar().rules[0].children[0].children[1].type == Rule::STRING_TYPE
    ok: ph.grammar().rules[0].children[0].children[1].repetition.min == 1
    ok: ph.grammar().rules[0].children[0].children[1].repetition.max == 1
      : ParserHarness ph( "$my_rule = { \"flt\":float ?, ((\"int\": integer, \"flt2\":float) | \"str\" : string) }\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::OBJECT
    ok: ph.grammar().rules[0].child_combiner == Rule::Sequence
    ok: ph.grammar().rules[0].children.size() == 2
    ok: ph.grammar().rules[0].children[0].type == Rule::FLOAT
    ok: ph.grammar().rules[0].children[0].member_name.is_literal()
    ok: ph.grammar().rules[0].children[0].member_name.name() == "flt"
    ok: ph.grammar().rules[0].children[0].repetition.min == 0
    ok: ph.grammar().rules[0].children[0].repetition.max == 1
    ok: ph.grammar().rules[0].children[0].children.size() == 0
    ok: ph.grammar().rules[0].children[1].type == Rule::OBJECT_GROUP
    ok: ph.grammar().rules[0].children[1].child_combiner == Rule::Choice
    ok: ph.grammar().rules[0].children[1].member_name.is_absent()
    ok: ph.grammar().rules[0].children[1].repetition.min == 1
    ok: ph.grammar().rules[0].children[1].repetition.max == 1
    ok: ph.grammar().rules[0].children[1].children.size() == 2
    ok: ph.grammar().rules[0].children[1].children[0].type == Rule::OBJECT_GROUP
    ok: ph.grammar().rules[0].children[1].children[0].child_combiner == Rule::Sequence
    ok: ph.grammar().rules[0].children[1].children[0].member_name.is_absent()
    ok: ph.grammar().rules[0].children[1].children[0].repetition.min == 1
    ok: ph.grammar().rules[0].children[1].children[0].repetition.max == 1
    ok: ph.grammar().rules[0].children[1].children[0].children.size() == 2
    ok: ph.grammar().rules[0].children[1].children[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[1].children[0].children[0].member_name.is_literal()
    ok: ph.grammar().rules[0].children[1].children[0].children[0].member_name.name() == "int"
    ok: ph.grammar().rules[0].children[1].children[0].children[0].repetition.min == 1
    ok: ph.grammar().rules[0].children[1].children[0].children[0].repetition.max == 1
    ok: ph.grammar().rules[0].children[1].children[0].children[0].children.size() == 0
    ok: ph.grammar().rules[0].children[1].children[0].children[1].type == Rule::FLOAT
    ok: ph.grammar().rules[0].children[1].children[0].children[1].member_name.is_literal()
    ok: ph.grammar().rules[0].children[1].children[0].children[1].member_name.name() == "flt2"
    ok: ph.grammar().rules[0].children[1].children[0].children[1].repetition.min == 1
    ok: ph.grammar().rules[0].children[1].children[0].children[1].repetition.max == 1
    ok: ph.grammar().rules[0].children[1].children[0].children[1].children.size() == 0
    ok: ph.grammar().rules[0].children[1].children[1].type == Rule::STRING_TYPE
    ok: ph.grammar().rules[0].children[1].children[1].member_name.is_literal()
    ok: ph.grammar().rules[0].children[1].children[1].member_name.name() == "str"
    ok: ph.grammar().rules[0].children[1].children[1].repetition.min == 1
    ok: ph.grammar().rules[0].children[1].children[1].repetition.max == 1
    ok: ph.grammar().rules[0].children[1].children[1].children.size() == 0
      : ParserHarness ph( "$my_rule = { \"flt\":float ?, () }\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::OBJECT
    ok: ph.grammar().rules[0].child_combiner == Rule::Sequence
    ok: ph.grammar().rules[0].children.size() == 2
    ok: ph.grammar().rules[0].children[0].type == Rule::FLOAT
    ok: ph.grammar().rules[0].children[0].member_name.is_literal()
    ok: ph.grammar().rules[0].children[0].member_name.name() == "flt"
    ok: ph.grammar().rules[0].children[0].repetition.min == 0
    ok: ph.grammar().rules[0].children[0].repetition.max == 1
    ok: ph.grammar().rules[0].children[0].children.size() == 0
    ok: ph.grammar().rules[0].children[1].type == Rule::OBJECT_GROUP
    ok: ph.grammar().rules[0].children[1].child_combiner == Rule::None
    ok: ph.grammar().rules[0].children[1].member_name.is_absent()
    ok: ph.grammar().rules[0].children[1].repetition.min == 1
    ok: ph.grammar().rules[0].children[1].repetition.max == 1
    ok: ph.grammar().rules[0].children[1].children.size() == 0
      : ParserHarness ph( "$my_rule = { \"member\" : { \"child\" : integer } }\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::OBJECT
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].type == Rule::OBJECT
      : ParserHarness ph( "$my_rule = { ( \"member\" : integer ) }\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::OBJECT
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].type == Rule::OBJECT_GROUP
      Calling: test_parsing_bad_input( "$my_rule = : { \"flt\":float?, \"flt2\":float | \"str\" : string }\n" ) (1920)
      #### $my_rule = : { "flt":float?, "flt2":float | "str" : string }
 ####
    ok: status != JCRParser::S_OK
      Calling: test_parsing_bad_input( "$my_rule = : {\"flt\":float ?, }\n" ) (1922)
      #### $my_rule = : {"flt":float ?, }
 ####
    ok: status != JCRParser::S_OK
    ok: ! _CrtMemDifference( &s3, &s1, &s2 )

    GrammarParser - Syntax parsing - array [test-parsing-only.cpp:1925]
    ===================================================================
      : ParserHarness ph( "$my_rule = [ integer ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].rule_name == ""
    ok: ph.grammar().rules[0].children[0].member_name.is_absent()
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
      : ParserHarness ph( "$my_rule = : [ integer ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].rule_name == ""
    ok: ph.grammar().rules[0].children[0].member_name.is_absent()
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
      : ParserHarness ph( "$my_rule = [ integer* ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].rule_name == ""
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].repetition.min == 0
    ok: ph.grammar().rules[0].children[0].repetition.max == -1
      : ParserHarness ph( "$my_rule = \"MyName\" : [ integer * ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].member_name.name() == "MyName"
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].rule_name == ""
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].repetition.min == 0
    ok: ph.grammar().rules[0].children[0].repetition.max == -1
      : ParserHarness ph( "$my_rule = \"MyName\":[integer*]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].member_name.name() == "MyName"
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].rule_name == ""
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].repetition.min == 0
    ok: ph.grammar().rules[0].children[0].repetition.max == -1
      : ParserHarness ph( "$my_rule = [ integer, string ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].child_combiner == Rule::Sequence
    ok: ph.grammar().rules[0].children.size() == 2
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[1].type == Rule::STRING_TYPE
      : ParserHarness ph( "$my_rule = [ integer | string ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].child_combiner == Rule::Choice
    ok: ph.grammar().rules[0].children.size() == 2
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[1].type == Rule::STRING_TYPE
      : ParserHarness ph( "$my_rule = [ integer | $my_type ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].child_combiner == Rule::Choice
    ok: ph.grammar().rules[0].children.size() == 2
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[1].type == Rule::TARGET_RULE
    ok: ph.grammar().rules[0].children[1].target_rule.local_name == "my_type"
      : ParserHarness ph( "$my_rule = [ (integer | string)*5 ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].child_combiner == Rule::None
    ok: ph.grammar().rules[0].children[0].type == Rule::ARRAY_GROUP
    ok: ph.grammar().rules[0].children[0].repetition.min == 5
    ok: ph.grammar().rules[0].children[0].repetition.max == 5
    ok: ph.grammar().rules[0].children[0].children.size() == 2
    ok: ph.grammar().rules[0].children[0].child_combiner == Rule::Choice
    ok: ph.grammar().rules[0].children[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].children[1].type == Rule::STRING_TYPE
      : ParserHarness ph( "$my_rule = [ (integer , string)*5 ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].child_combiner == Rule::None
    ok: ph.grammar().rules[0].children[0].type == Rule::ARRAY_GROUP
    ok: ph.grammar().rules[0].children[0].annotations.is_not == false
    ok: ph.grammar().rules[0].children[0].repetition.min == 5
    ok: ph.grammar().rules[0].children[0].repetition.max == 5
    ok: ph.grammar().rules[0].children[0].children.size() == 2
    ok: ph.grammar().rules[0].children[0].child_combiner == Rule::Sequence
    ok: ph.grammar().rules[0].children[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].children[1].type == Rule::STRING_TYPE
      : ParserHarness ph( "$my_rule = [ @{not}(integer , string)*5 ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].child_combiner == Rule::None
    ok: ph.grammar().rules[0].children[0].type == Rule::ARRAY_GROUP
    ok: ph.grammar().rules[0].children[0].annotations.is_not == true
    ok: ph.grammar().rules[0].children[0].repetition.min == 5
    ok: ph.grammar().rules[0].children[0].repetition.max == 5
    ok: ph.grammar().rules[0].children[0].children.size() == 2
    ok: ph.grammar().rules[0].children[0].child_combiner == Rule::Sequence
    ok: ph.grammar().rules[0].children[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].children[1].type == Rule::STRING_TYPE
      : ParserHarness ph( "$my_rule = [ float*5, ( integer | string) ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 2
    ok: ph.grammar().rules[0].child_combiner == Rule::Sequence
    ok: ph.grammar().rules[0].children[0].type == Rule::FLOAT
    ok: ph.grammar().rules[0].children[0].repetition.min == 5
    ok: ph.grammar().rules[0].children[0].repetition.max == 5
    ok: ph.grammar().rules[0].children[1].type == Rule::ARRAY_GROUP
    ok: ph.grammar().rules[0].children[1].children.size() == 2
    ok: ph.grammar().rules[0].children[1].child_combiner == Rule::Choice
    ok: ph.grammar().rules[0].children[1].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[1].children[1].type == Rule::STRING_TYPE
      : ParserHarness ph( "$my_rule = [ float *5, ( integer | string) ?]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 2
    ok: ph.grammar().rules[0].child_combiner == Rule::Sequence
    ok: ph.grammar().rules[0].children[0].type == Rule::FLOAT
    ok: ph.grammar().rules[0].children[0].repetition.min == 5
    ok: ph.grammar().rules[0].children[0].repetition.max == 5
    ok: ph.grammar().rules[0].children[1].type == Rule::ARRAY_GROUP
    ok: ph.grammar().rules[0].children[1].repetition.min == 0
    ok: ph.grammar().rules[0].children[1].repetition.max == 1
    ok: ph.grammar().rules[0].children[1].children.size() == 2
    ok: ph.grammar().rules[0].children[1].child_combiner == Rule::Choice
    ok: ph.grammar().rules[0].children[1].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[1].children[1].type == Rule::STRING_TYPE
      : ParserHarness ph( "$my_rule = [ float *5,(integer | string+) ? ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 2
    ok: ph.grammar().rules[0].child_combiner == Rule::Sequence
    ok: ph.grammar().rules[0].children[0].type == Rule::FLOAT
    ok: ph.grammar().rules[0].children[0].repetition.min == 5
    ok: ph.grammar().rules[0].children[0].repetition.max == 5
    ok: ph.grammar().rules[0].children[1].type == Rule::ARRAY_GROUP
    ok: ph.grammar().rules[0].children[1].repetition.min == 0
    ok: ph.grammar().rules[0].children[1].repetition.max == 1
    ok: ph.grammar().rules[0].children[1].children.size() == 2
    ok: ph.grammar().rules[0].children[1].child_combiner == Rule::Choice
    ok: ph.grammar().rules[0].children[1].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[1].children[1].type == Rule::STRING_TYPE
    ok: ph.grammar().rules[0].children[1].children[1].repetition.min == 1
    ok: ph.grammar().rules[0].children[1].children[1].repetition.max == -1
      : ParserHarness ph( "$my_rule = [ float *5 , (( integer, float) | string) ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 2
    ok: ph.grammar().rules[0].child_combiner == Rule::Sequence
    ok: ph.grammar().rules[0].children[0].type == Rule::FLOAT
    ok: ph.grammar().rules[0].children[0].repetition.min == 5
    ok: ph.grammar().rules[0].children[0].repetition.max == 5
    ok: ph.grammar().rules[0].children[1].type == Rule::ARRAY_GROUP
    ok: ph.grammar().rules[0].children[1].children.size() == 2
    ok: ph.grammar().rules[0].children[1].child_combiner == Rule::Choice
    ok: ph.grammar().rules[0].children[1].children[0].type == Rule::ARRAY_GROUP
    ok: ph.grammar().rules[0].children[1].children[0].children.size() == 2
    ok: ph.grammar().rules[0].children[1].children[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[1].children[0].children[1].type == Rule::FLOAT
    ok: ph.grammar().rules[0].children[1].children[1].type == Rule::STRING_TYPE
      Calling: test_parsing_bad_input( "$my_rule = [ integer, float | string ]\n" ) (2168)
      #### $my_rule = [ integer, float | string ]
 ####
    ok: status != JCRParser::S_OK
      Calling: test_parsing_bad_input( "$my_rule = [ integer, ]\n" ) (2170)
      #### $my_rule = [ integer, ]
 ####
    ok: status != JCRParser::S_OK
    ok: ! _CrtMemDifference( &s3, &s1, &s2 )

    GrammarParser - Syntax parsing - group [test-parsing-only.cpp:2173]
    ===================================================================
      : ParserHarness ph( "$my_rule = ( integer )\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::GROUP
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].rule_name == ""
    ok: ph.grammar().rules[0].children[0].member_name.is_absent()
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
      : ParserHarness ph( "$my_rule = ( \"name\" : integer )\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::GROUP
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].rule_name == ""
    ok: ph.grammar().rules[0].children[0].member_name.is_literal()
    ok: ph.grammar().rules[0].children[0].member_name.name() == "name"
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
      : ParserHarness ph( "$my_rule = ( /p-\\d+/ : integer )\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::GROUP
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].rule_name == ""
    ok: ph.grammar().rules[0].children[0].member_name.is_regex()
    ok: ph.grammar().rules[0].children[0].member_name.name() == "/p-\\d+/"
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
      : ParserHarness ph( "$my_rule = ( $other-rule )\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::GROUP
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].rule_name == ""
    ok: ph.grammar().rules[0].children[0].member_name.is_absent()
    ok: ph.grammar().rules[0].children[0].type == Rule::TARGET_RULE
    ok: ph.grammar().rules[0].children[0].target_rule.local_name == "other-rule"
      : ParserHarness ph( "$my_rule = ( float *5, ((integer, float) | string) )\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::GROUP
    ok: ph.grammar().rules[0].children.size() == 2
    ok: ph.grammar().rules[0].child_combiner == Rule::Sequence
    ok: ph.grammar().rules[0].children[0].type == Rule::FLOAT
    ok: ph.grammar().rules[0].children[0].repetition.min == 5
    ok: ph.grammar().rules[0].children[0].repetition.max == 5
    ok: ph.grammar().rules[0].children[1].type == Rule::GROUP_GROUP
    ok: ph.grammar().rules[0].children[1].children.size() == 2
    ok: ph.grammar().rules[0].children[1].child_combiner == Rule::Choice
    ok: ph.grammar().rules[0].children[1].children[0].type == Rule::GROUP_GROUP
    ok: ph.grammar().rules[0].children[1].children[0].children.size() == 2
    ok: ph.grammar().rules[0].children[1].children[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[1].children[0].children[1].type == Rule::FLOAT
    ok: ph.grammar().rules[0].children[1].children[1].type == Rule::STRING_TYPE
      : ParserHarness ph( "$my_rule = ( \"flt\":float?, ((\"int\": integer, \"flt2\":float) | \"str\" : string) )\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::GROUP
    ok: ph.grammar().rules[0].child_combiner == Rule::Sequence
    ok: ph.grammar().rules[0].children.size() == 2
    ok: ph.grammar().rules[0].children[0].type == Rule::FLOAT
    ok: ph.grammar().rules[0].children[0].member_name.is_literal()
    ok: ph.grammar().rules[0].children[0].member_name.name() == "flt"
    ok: ph.grammar().rules[0].children[0].repetition.min == 0
    ok: ph.grammar().rules[0].children[0].repetition.max == 1
    ok: ph.grammar().rules[0].children[0].children.size() == 0
    ok: ph.grammar().rules[0].children[1].type == Rule::GROUP_GROUP
    ok: ph.grammar().rules[0].children[1].child_combiner == Rule::Choice
    ok: ph.grammar().rules[0].children[1].member_name.is_absent()
    ok: ph.grammar().rules[0].children[1].repetition.min == 1
    ok: ph.grammar().rules[0].children[1].repetition.max == 1
    ok: ph.grammar().rules[0].children[1].children.size() == 2
    ok: ph.grammar().rules[0].children[1].children[0].type == Rule::GROUP_GROUP
    ok: ph.grammar().rules[0].children[1].children[0].child_combiner == Rule::Sequence
    ok: ph.grammar().rules[0].children[1].children[0].member_name.is_absent()
    ok: ph.grammar().rules[0].children[1].children[0].repetition.min == 1
    ok: ph.grammar().rules[0].children[1].children[0].repetition.max == 1
    ok: ph.grammar().rules[0].children[1].children[0].children.size() == 2
    ok: ph.grammar().rules[0].children[1].children[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[1].children[0].children[0].member_name.is_literal()
    ok: ph.grammar().rules[0].children[1].children[0].children[0].member_name.name() == "int"
    ok: ph.grammar().rules[0].children[1].children[0].children[0].repetition.min == 1
    ok: ph.grammar().rules[0].children[1].children[0].children[0].repetition.max == 1
    ok: ph.grammar().rules[0].children[1].children[0].children[0].children.size() == 0
    ok: ph.grammar().rules[0].children[1].children[0].children[1].type == Rule::FLOAT
    ok: ph.grammar().rules[0].children[1].children[0].children[1].member_name.is_literal()
    ok: ph.grammar().rules[0].children[1].children[0].children[1].member_name.name() == "flt2"
    ok: ph.grammar().rules[0].children[1].children[0].children[1].repetition.min == 1
    ok: ph.grammar().rules[0].children[1].children[0].children[1].repetition.max == 1
    ok: ph.grammar().rules[0].children[1].children[0].children[1].children.size() == 0
    ok: ph.grammar().rules[0].children[1].children[1].type == Rule::STRING_TYPE
    ok: ph.grammar().rules[0].children[1].children[1].member_name.is_literal()
    ok: ph.grammar().rules[0].children[1].children[1].member_name.name() == "str"
    ok: ph.grammar().rules[0].children[1].children[1].repetition.min == 1
    ok: ph.grammar().rules[0].children[1].children[1].repetition.max == 1
    ok: ph.grammar().rules[0].children[1].children[1].children.size() == 0
      : ParserHarness ph( "#{import http://foo.com as my_alias} $my_rule = ( float*5, (( 1..5, \"name\":float) | $my_alias.other-rule | [ integer, /p*/ ] ) )\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::GROUP
    ok: ph.grammar().rules[0].children.size() == 2
    ok: ph.grammar().rules[0].child_combiner == Rule::Sequence
    ok: ph.grammar().rules[0].children[0].type == Rule::FLOAT
    ok: ph.grammar().rules[0].children[0].repetition.min == 5
    ok: ph.grammar().rules[0].children[0].repetition.max == 5
    ok: ph.grammar().rules[0].children[0].member_name.is_absent()
    ok: ph.grammar().rules[0].children[1].type == Rule::GROUP_GROUP
    ok: ph.grammar().rules[0].children[1].children.size() == 3
    ok: ph.grammar().rules[0].children[1].child_combiner == Rule::Choice
    ok: ph.grammar().rules[0].children[1].children[0].type == Rule::GROUP_GROUP
    ok: ph.grammar().rules[0].children[1].children[0].children.size() == 2
    ok: ph.grammar().rules[0].children[1].children[0].children[0].type == Rule::UINTEGER
    ok: ph.grammar().rules[0].children[1].children[0].children[0].min.is_uint() == true
    ok: ph.grammar().rules[0].children[1].children[0].children[0].min.as_uint() == 1
    ok: ph.grammar().rules[0].children[1].children[0].children[0].max.is_uint() == true
    ok: ph.grammar().rules[0].children[1].children[0].children[0].max.as_uint() == 5
    ok: ph.grammar().rules[0].children[1].children[0].children[1].type == Rule::FLOAT
    ok: ph.grammar().rules[0].children[1].children[0].children[1].member_name.is_literal()
    ok: ph.grammar().rules[0].children[1].children[0].children[1].member_name.name() == "name"
    ok: ph.grammar().rules[0].children[1].children[1].type == Rule::TARGET_RULE
    ok: ph.grammar().rules[0].children[1].children[1].target_rule.rulesetid == "http://foo.com"
    ok: ph.grammar().rules[0].children[1].children[1].target_rule.local_name == "other-rule"
    ok: ph.grammar().rules[0].children[1].children[1].children.size() == 0
    ok: ph.grammar().rules[0].children[1].children[2].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children[1].children[2].children.size() == 2
    ok: ph.grammar().rules[0].children[1].children[2].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[1].children[2].children[0].member_name.is_absent()
    ok: ph.grammar().rules[0].children[1].children[2].children[1].type == Rule::STRING_REGEX
    ok: ph.grammar().rules[0].children[1].children[2].children[1].member_name.is_absent()
    ok: ph.grammar().rules[0].children[1].children[2].children[1].min.is_string() == true
    ok: ph.grammar().rules[0].children[1].children[2].children[1].min.as_string() == "/p*/"
      Calling: test_parsing_bad_input( "$my_rule = (integer,float|string )\n" ) (2347)
      #### $my_rule = (integer,float|string )
 ####
    ok: status != JCRParser::S_OK
      Calling: test_parsing_bad_input( "$my_rule = (integer, )\n" ) (2349)
      #### $my_rule = (integer, )
 ####
    ok: status != JCRParser::S_OK
    ok: ! _CrtMemDifference( &s3, &s1, &s2 )

    GrammarParser - Syntax parsing - repetition [test-parsing-only.cpp:2352]
    ========================================================================
      : ParserHarness ph( "$my_rule = [ integer ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].repetition.min == 1
    ok: ph.grammar().rules[0].children[0].repetition.max == 1
    ok: ph.grammar().rules[0].children[0].repetition.step == 1
      : ParserHarness ph( "$my_rule = [ integer ? ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].repetition.min == 0
    ok: ph.grammar().rules[0].children[0].repetition.max == 1
    ok: ph.grammar().rules[0].children[0].repetition.step == 1
      : ParserHarness ph( "$my_rule = [ integer* ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].repetition.min == 0
    ok: ph.grammar().rules[0].children[0].repetition.max == -1
    ok: ph.grammar().rules[0].children[0].repetition.step == 1
      : ParserHarness ph( "$my_rule = [ integer*%3 ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].repetition.min == 0
    ok: ph.grammar().rules[0].children[0].repetition.max == -1
    ok: ph.grammar().rules[0].children[0].repetition.step == 3
      : ParserHarness ph( "$my_rule = [integer+]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].repetition.min == 1
    ok: ph.grammar().rules[0].children[0].repetition.max == -1
    ok: ph.grammar().rules[0].children[0].repetition.step == 1
      : ParserHarness ph( "$my_rule = [integer+%2]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].repetition.min == 1
    ok: ph.grammar().rules[0].children[0].repetition.max == -1
    ok: ph.grammar().rules[0].children[0].repetition.step == 2
      : ParserHarness ph( "$my_rule = [  integer *5  ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].repetition.min == 5
    ok: ph.grammar().rules[0].children[0].repetition.max == 5
    ok: ph.grammar().rules[0].children[0].repetition.step == 1
      : ParserHarness ph( "$my_rule = [ integer*5.. ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].repetition.min == 5
    ok: ph.grammar().rules[0].children[0].repetition.max == -1
    ok: ph.grammar().rules[0].children[0].repetition.step == 1
      : ParserHarness ph( "$my_rule = [ integer*5..%7 ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].repetition.min == 5
    ok: ph.grammar().rules[0].children[0].repetition.max == -1
    ok: ph.grammar().rules[0].children[0].repetition.step == 7
      : ParserHarness ph( "$my_rule = [ integer*145.. ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].repetition.min == 145
    ok: ph.grammar().rules[0].children[0].repetition.max == -1
    ok: ph.grammar().rules[0].children[0].repetition.step == 1
      : ParserHarness ph( "$my_rule = [ integer*145..%17 ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].repetition.min == 145
    ok: ph.grammar().rules[0].children[0].repetition.max == -1
    ok: ph.grammar().rules[0].children[0].repetition.step == 17
      : ParserHarness ph( "$my_rule=[integer*..5]" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].repetition.min == 0
    ok: ph.grammar().rules[0].children[0].repetition.max == 5
    ok: ph.grammar().rules[0].children[0].repetition.step == 1
      : ParserHarness ph( "$my_rule=[integer*..5%2]" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].repetition.min == 0
    ok: ph.grammar().rules[0].children[0].repetition.max == 5
    ok: ph.grammar().rules[0].children[0].repetition.step == 2
      : ParserHarness ph( "$my_rule=[integer*..145]" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].repetition.min == 0
    ok: ph.grammar().rules[0].children[0].repetition.max == 145
    ok: ph.grammar().rules[0].children[0].repetition.step == 1
      : ParserHarness ph( "$my_rule=[integer*..145%32]" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].repetition.min == 0
    ok: ph.grammar().rules[0].children[0].repetition.max == 145
    ok: ph.grammar().rules[0].children[0].repetition.step == 32
      : ParserHarness ph( "$my_rule = [ integer *2..5 ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].repetition.min == 2
    ok: ph.grammar().rules[0].children[0].repetition.max == 5
    ok: ph.grammar().rules[0].children[0].repetition.step == 1
      : ParserHarness ph( "$my_rule = [ integer *2..5%4 ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].repetition.min == 2
    ok: ph.grammar().rules[0].children[0].repetition.max == 5
    ok: ph.grammar().rules[0].children[0].repetition.step == 4
      : ParserHarness ph( "$my_rule = [ integer *142..145 ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].repetition.min == 142
    ok: ph.grammar().rules[0].children[0].repetition.max == 145
    ok: ph.grammar().rules[0].children[0].repetition.step == 1
      : ParserHarness ph( "$my_rule = [ integer *142..145%24 ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].repetition.min == 142
    ok: ph.grammar().rules[0].children[0].repetition.max == 145
    ok: ph.grammar().rules[0].children[0].repetition.step == 24
      : ParserHarness ph( "$my_rule = { \"size\" : integer *2..5%4 }\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].type == Rule::OBJECT
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].repetition.min == 2
    ok: ph.grammar().rules[0].children[0].repetition.max == 5
    ok: ph.grammar().rules[0].children[0].repetition.step == 4
      : ParserHarness ph( "$my_rule = { (\"size\" : integer) *2..5%4 }\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].type == Rule::OBJECT
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].type == Rule::OBJECT_GROUP
    ok: ph.grammar().rules[0].children[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].repetition.min == 2
    ok: ph.grammar().rules[0].children[0].repetition.max == 5
    ok: ph.grammar().rules[0].children[0].repetition.step == 4
      : ParserHarness ph( "$my_rule = ( \"size\" : integer *2..5%4 )" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].type == Rule::GROUP
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].repetition.min == 2
    ok: ph.grammar().rules[0].children[0].repetition.max == 5
    ok: ph.grammar().rules[0].children[0].repetition.step == 4
      Calling: test_parsing_bad_input( "$my_rule = [ integer *142.]" ) (2622)
      #### $my_rule = [ integer *142.] ####
    ok: status != JCRParser::S_OK
      Calling: test_parsing_bad_input( "$my_rule = [ integer *142..% ]" ) (2624)
      #### $my_rule = [ integer *142..% ] ####
    ok: status != JCRParser::S_OK
      Calling: test_parsing_bad_input( "$my_rule = [ integer *.. ]" ) (2626)
      #### $my_rule = [ integer *.. ] ####
    ok: status != JCRParser::S_OK
      Calling: test_parsing_bad_input( "$my_rule = [ integer *..%24 ]" ) (2628)
      #### $my_rule = [ integer *..%24 ] ####
    ok: status != JCRParser::S_OK
      Calling: test_parsing_bad_input( "$my_rule = [ integer *..145%-12 ]" ) (2630)
      #### $my_rule = [ integer *..145%-12 ] ####
    ok: status != JCRParser::S_OK
      Calling: test_parsing_bad_input( "$my_rule = [ integer *-142..-145%24 ]" ) (2632)
      #### $my_rule = [ integer *-142..-145%24 ] ####
    ok: status != JCRParser::S_OK
      Calling: test_parsing_bad_input( "$my_rule = [ integer *..-145 ]" ) (2634)
      #### $my_rule = [ integer *..-145 ] ####
    ok: status != JCRParser::S_OK
      Calling: test_parsing_bad_input( "$my_rule = [ integer *-142.. ]" ) (2636)
      #### $my_rule = [ integer *-142.. ] ####
    ok: status != JCRParser::S_OK
    ok: ! _CrtMemDifference( &s3, &s1, &s2 )

    GrammarParser - Syntax parsing - annotations [test-parsing-only.cpp:2639]
    =========================================================================
      Calling: test_parsing_only( "$my_rule = @{not} $other_rule\n" ) (2642)
      #### $my_rule = @{not} $other_rule
 ####
    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "$my_rule = [ @{id type} string, float ]\n" ) (2644)
      #### $my_rule = [ @{id type} string, float ]
 ####
    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "$my_rule = [ @{id type} string, @{when $type} float? ]\n" ) (2646)
      #### $my_rule = [ @{id type} string, @{when $type} float? ]
 ####
    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "$my_rule = [ @{id type} string, @{when $type}@{assert $ > 15.0} float ? ]\n" ) (2648)
      #### $my_rule = [ @{id type} string, @{when $type}@{assert $ > 15.0} float ? ]
 ####
    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "$my_rule = [ @{id type}@{assert $==\"in\" || $==\"out\"} string, float ? ]\n" ) (2650)
      #### $my_rule = [ @{id type}@{assert $=="in" || $=="out"} string, float ? ]
 ####
    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "$my_rule = [ @{id type}@{assert $==/^\\w{1,4}$/} string, float? ]\n" ) (2652)
      #### $my_rule = [ @{id type}@{assert $==/^\w{1,4}$/} string, float? ]
 ####
    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "$my_rule = [ @{id type}@{assert $==/^\\w{1,4}$/ ; Must for 4 or less chars{}\n} string, float? ]\n" ) (2654)
      #### $my_rule = [ @{id type}@{assert $==/^\w{1,4}$/ ; Must for 4 or less chars{}
} string, float? ]
 ####
    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "$my_rule=[@{not}string,float ]\n" ) (2656)
      #### $my_rule=[@{not}string,float ]
 ####
    ok: status == JCRParser::S_OK
      Calling: test_parsing_bad_input( "$my_rule=[@{unknown}string,float ]\n" ) (2658)
      #### $my_rule=[@{unknown}string,float ]
 ####
    ok: status != JCRParser::S_OK
    ok: ! _CrtMemDifference( &s3, &s1, &s2 )
    ok: _CrtCheckMemory() != 0

TODOs (2):
------------------------
- Implement and test GrammarSet::link() [test-grammar-set.cpp:42]
- Test low level GrammarSet class [test-low-level-objects.cpp:264]

0 error(s), 2 todo(s), 1860 test(s)
