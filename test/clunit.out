Tests run on Thu Feb 18 17:46:45 2016

    GrammarSet TODOS [test-grammar-set.cpp:40]
    ==========================================
    ok: ! _CrtMemDifference( &s3, &s1, &s2 )

    ValueConstraint [test-low-level-objects.cpp:40]
    ===============================================
    ok: vc.is_set() == false
      : vc = "true"
    ok: vc.is_set() == true
    ok: vc == "true"
    ok: vc == std::string( "true" )
    ok: vc != "other"
    ok: vc != std::string( "other" )
    ok: vc.to_string() == "true"
    ok: vc.to_bool() == true
    ok: vc.to_int() == 0
    ok: vc.to_float() == 0
      : vc = "false"
    ok: vc.is_set() == true
    ok: vc == "false"
    ok: vc.to_bool() == false
    ok: vc.to_int() == 0
    ok: vc.to_float() == 0
      : vc = "foo"
    ok: vc.is_set() == true
    ok: vc == "foo"
    ok: vc.to_bool() == false
    ok: vc.to_int() == 0
    ok: vc.to_float() == 0
      : vc = "10"
    ok: vc.is_set() == true
    ok: vc == "10"
    ok: vc.to_bool() == false
    ok: vc.to_int() == 10
    ok: vc.to_float() == 10.0
      : vc = "10.5"
    ok: vc.is_set() == true
    ok: vc == "10.5"
    ok: vc.to_bool() == false
    ok: vc.to_int() == 10
    ok: vc.to_float() == 10.5
      : vc = "2.5e+3"
    ok: vc.is_set() == true
    ok: vc == "2.5e+3"
    ok: vc.to_bool() == false
    ok: vc.to_int() == 2
    ok: vc.to_float() == 2500.0
      : vc.clear()
    ok: vc.is_set() == false
    ok: vc == ""
    ok: ! _CrtMemDifference( &s3, &s1, &s2 )

    MemberName [test-low-level-objects.cpp:97]
    ==========================================
    ok: mn.is_absent() == true
    ok: mn.is_literal() == false
    ok: mn.is_regex() == false
    ok: mn.name() == ""
      : mn.set_literal( "foo" )
    ok: mn.is_absent() == false
    ok: mn.is_literal() == true
    ok: mn.is_regex() == false
    ok: mn.name() == "foo"
      : mn.set_regex( "/name*/i" )
    ok: mn.is_absent() == false
    ok: mn.is_literal() == false
    ok: mn.is_regex() == true
    ok: mn.name() == "/name*/i"
      : mn.set_absent()
    ok: mn.is_absent() == true
    ok: mn.is_literal() == false
    ok: mn.is_regex() == false
    ok: mn.name() == ""
    ok: ! _CrtMemDifference( &s3, &s1, &s2 )

    TargetRule [test-low-level-objects.cpp:125]
    ===========================================
    ok: ! tr.p_rule
    ok: ! _CrtMemDifference( &s3, &s1, &s2 )

    Rule [test-low-level-objects.cpp:132]
    =====================================
    ok: ! r.p_parent
    ok: r.type == Rule::NONE
      : Rule::uniq_ptr pu_rule( new Rule )
    ok: ! pu_rule->p_parent
    ok: pu_rule->type == Rule::NONE
      : Rule * p_new_rule = pu_rule.get()
      : Rule * p_appended_rule = r.append_child_rule( pu_rule )
    ok: p_appended_rule == p_new_rule
    ok: p_appended_rule->p_parent == &r
    ok: ! _CrtMemDifference( &s3, &s1, &s2 )

    Grammar [test-low-level-objects.cpp:150]
    ========================================
      Adding and accessing unaliased imports
      : g.add_unaliased_import( "foo" )
    ok: g.unaliased_imports.size() == 1
      : g.add_unaliased_import( "bar" )
    ok: g.unaliased_imports.size() == 2
    ok: g.unaliased_imports[0] == "foo"
    ok: g.unaliased_imports[1] == "bar"
      Adding aliased imports
    ok: g.has_aliased_import( "foo" ) == false
    ok: g.add_aliased_import( "foo", "http://foo" ) == true
    ok: g.has_aliased_import( "foo" ) == true
    ok: g.has_aliased_import( "bar" ) == false
    ok: g.add_aliased_import( "bar", "http://bar" ) == true
    ok: g.has_aliased_import( "bar" ) == true
    ok: g.aliased_imports["foo"] == "http://foo"
    ok: g.aliased_imports["bar"] == "http://bar"
      Adding duplicate aliased imports fails
    ok: g.add_aliased_import( "foo", "http://foo" ) == false
      Accessing aliased imports for const instances
      : const Grammar & r_g( g )
    ok: r_g.get_aliased_import( "foo" ).value() == "http://foo"
      : std::string foo = r_g.get_aliased_import( "foo" )
    ok: foo == "http://foo"
    ok: r_g.get_aliased_import( "bar" ).value() == "http://bar"
    ok: r_g.has_aliased_import( "blah" ) == false
    ok: r_g.get_aliased_import( "blah" ).is_found() == false
      Adding rules
    ok: g.rules.size() == 0
      : Rule::uniq_ptr pu_r( new Rule )
      : pu_r->p_parent = pu_r.get()
    ok: pu_r->p_parent != 0
      : Rule * p_unmanaged_rule = pu_r.get()
      : Rule * p_r = g.append_rule( pu_r )
    ok: p_r == p_unmanaged_rule
    ok: ! p_r->p_parent
    ok: g.rules.size() == 1
    ok: ! _CrtMemDifference( &s3, &s1, &s2 )

    ok: ! _CrtMemDifference( &s3, &s1, &s2 )

    Miscellaneous TODOs [test-main.cpp:37]
    ======================================
    ok: ! _CrtMemDifference( &s3, &s1, &s2 )

    GrammarParser - Syntax parsing with no semantic interpretation - comments [test-parsing-only.cpp:62]
    ====================================================================================================
      Calling: test_parsing_only( "" ) (65)
      
    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "   " ) (67)
         
    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "; Hello World" ) (69)
      ; Hello World
    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "; Hello World" ) (71)
      ; Hello World
    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "; Hello World\n" "     " ) (74)
      ; Hello World
     
    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "; Hello World\n" "     \n" "  ; Let's go..." ) (78)
      ; Hello World
     
  ; Let's go...
    ok: status == JCRParser::S_OK
      Calling: test_parsing_bad_input( "; Hello World ; Let's go...\n" ) (80)
      ; Hello World ; Let's go...

    ok: status != JCRParser::S_OK
      Calling: test_parsing_only( "; Hello World ;; Let's go...\n" ) (82)
      ; Hello World ;; Let's go...

    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "" ) (84)
      
    ok: status == JCRParser::S_OK
    ok: ! _CrtMemDifference( &s3, &s1, &s2 )

    GrammarParser - Syntax parsing - JCR directive [test-parsing-only.cpp:87]
    =========================================================================
      Calling: test_parsing_only( "#jcr-version 0.5" ) (90)
      #jcr-version 0.5
    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "#jcr-version 0.5 " ) (92)
      #jcr-version 0.5 
    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "#jcr-version 0.5 \t" ) (94)
      #jcr-version 0.5 	
    ok: status == JCRParser::S_OK
      Calling: test_parsing_bad_input( "#\n" "jcr-version\n" " 0.5" ) (98)
      #
jcr-version
 0.5
    ok: status != JCRParser::S_OK
      Calling: test_parsing_bad_input( "#jcr-version 0.12" ) (100)
      #jcr-version 0.12
    ok: status != JCRParser::S_OK
      Calling: test_parsing_bad_input( "#jcr-version 10.5" ) (102)
      #jcr-version 10.5
    ok: status != JCRParser::S_OK
      Calling: test_parsing_bad_input( "#jcr-version 0.5 too long" ) (104)
      #jcr-version 0.5 too long
    ok: status != JCRParser::S_OK
      Calling: test_parsing_only( "; Start\n" "#jcr-version 0.5" ) (107)
      ; Start
#jcr-version 0.5
    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "; Start\n" "#jcr-version 0.5\n" "; End" ) (111)
      ; Start
#jcr-version 0.5
; End
    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "  #jcr-version 0.5\n" "; End" ) (114)
        #jcr-version 0.5
; End
    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "; Start ; #jcr-version 0.5" ) (116)
      ; Start ; #jcr-version 0.5
    ok: status == JCRParser::S_OK
      Calling: test_parsing_bad_input( "#jcr-version0.5" ) (118)
      #jcr-version0.5
    ok: status != JCRParser::S_OK
      Calling: test_parsing_bad_input( "#jcr-version a.5" ) (120)
      #jcr-version a.5
    ok: status != JCRParser::S_OK
      Calling: test_parsing_bad_input( "#jcr-version 0:5" ) (122)
      #jcr-version 0:5
    ok: status != JCRParser::S_OK
      Calling: test_parsing_bad_input( "#jcr-version 0.b" ) (124)
      #jcr-version 0.b
    ok: status != JCRParser::S_OK
    ok: ! _CrtMemDifference( &s3, &s1, &s2 )

    GrammarParser - Syntax parsing - ruleset-id directive [test-parsing-only.cpp:127]
    =================================================================================
      Calling: test_parsing_only( "#ruleset-id http://www.example.com/jcr\n" ) (130)
      #ruleset-id http://www.example.com/jcr

    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "#ruleset-id http://www.example.com/jcr \n" ) (132)
      #ruleset-id http://www.example.com/jcr 

    ok: status == JCRParser::S_OK
      Calling: test_parsing_bad_input( "#ruleset-id \n" ) (134)
      #ruleset-id 

    ok: status != JCRParser::S_OK
      Calling: test_parsing_bad_input( "#ruleset-id\n" ) (136)
      #ruleset-id

    ok: status != JCRParser::S_OK
      Calling: test_parsing_only( "; A comment ; #ruleset-id http://www.example.com/jcr\n" ) (138)
      ; A comment ; #ruleset-id http://www.example.com/jcr

    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "#ruleset-id http://www.example.com/jcr\n" "; A comment" ) (141)
      #ruleset-id http://www.example.com/jcr
; A comment
    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "#ruleset-id http://www.example.com/jcr\n" "; A comment\n" "; Another comment\n" "#jcr-version 0.5\n" ) (146)
      #ruleset-id http://www.example.com/jcr
; A comment
; Another comment
#jcr-version 0.5

    ok: status == JCRParser::S_OK
      : ParserHarness ph( "#ruleset-id http://www.example.com/jcr" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().ruleset_id == "http://www.example.com/jcr"
    ok: ! _CrtMemDifference( &s3, &s1, &s2 )

    GrammarParser - Syntax parsing - import directive [test-parsing-only.cpp:154]
    =============================================================================
      Calling: test_parsing_only( "#import http://www.example.com/jcr\n" ) (157)
      #import http://www.example.com/jcr

    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "#import http://www.example.com/jcr \n" ) (159)
      #import http://www.example.com/jcr 

    ok: status == JCRParser::S_OK
      Calling: test_parsing_bad_input( "#import http://www.example.com/jcr as\n" ) (161)
      #import http://www.example.com/jcr as

    ok: status != JCRParser::S_OK
      Calling: test_parsing_bad_input( "#import http://www.example.com/jcr as \n" ) (163)
      #import http://www.example.com/jcr as 

    ok: status != JCRParser::S_OK
      Calling: test_parsing_only( "#import http://www.example.com/jcr as my_1st-alias\n" ) (165)
      #import http://www.example.com/jcr as my_1st-alias

    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "#import http://www.example.com/jcr as my_1st-alias \n" ) (167)
      #import http://www.example.com/jcr as my_1st-alias 

    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( " ; Hello\n" "#import http://www.example.com/jcr as  my_1st-alias\n" ) (170)
       ; Hello
#import http://www.example.com/jcr as  my_1st-alias

    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( " ; Hello\n" "#jcr-version 0.5\n" "#ruleset-id http://www.example.com/jcr\n" "#import http://www.example.com/jcr as  my_1st-alias\n" "#import http://www.example.com/jcr2 as  my_2nd-alias\n" "\n" ) (177)
       ; Hello
#jcr-version 0.5
#ruleset-id http://www.example.com/jcr
#import http://www.example.com/jcr as  my_1st-alias
#import http://www.example.com/jcr2 as  my_2nd-alias


    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( " ; Hello\n" "#jcr-version 0.5\n" "  ; A comment\n" "#ruleset-id http://www.example.com/jcr\n" "  ; A comment\n" "  ; A comment\n" "#import http://www.example.com/jcr as  my_1st-alias\n" "  ; A comment\n" "  ; A comment\n" "  ; A comment\n" "  ; A comment\n" "#import http://www.example.com/jcr2 as  my_2nd-alias\n" "\n" ) (191)
       ; Hello
#jcr-version 0.5
  ; A comment
#ruleset-id http://www.example.com/jcr
  ; A comment
  ; A comment
#import http://www.example.com/jcr as  my_1st-alias
  ; A comment
  ; A comment
  ; A comment
  ; A comment
#import http://www.example.com/jcr2 as  my_2nd-alias


    ok: status == JCRParser::S_OK
      : ParserHarness ph( "#import http://www.example.com/jcr" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().unaliased_imports[0] == "http://www.example.com/jcr"
      : ParserHarness ph( "#import http://www.example.com/jcr as jcr" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().has_aliased_import( "jcr" )
    ok: ph.grammar().get_aliased_import( "jcr" ).value() == "http://www.example.com/jcr"
    ok: ! _CrtMemDifference( &s3, &s1, &s2 )

    GrammarParser - Syntax parsing - multi-line directive [test-parsing-only.cpp:205]
    =================================================================================
      Calling: test_parsing_only( "#{constraint foo \n" "  $id == 'None' }\n" ) (209)
      #{constraint foo 
  $id == 'None' }

    ok: status == JCRParser::S_OK
      : ParserHarness ph( "#{constraint foo\n" "    $name == /p\\d{1,5}/ && ; Must allow } and { in comments\n" "    $when == \"} with {\"\n" "}\n" "my_rule other_rule\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ! _CrtMemDifference( &s3, &s1, &s2 )

    GrammarParser - Syntax parsing - TBD directive [test-parsing-only.cpp:223]
    ==========================================================================
      Calling: test_parsing_only( "#TBD\n" ) (226)
      #TBD

    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "#TBD  we\n" ) (228)
      #TBD  we

    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "#TBD  we don't know\n" ) (230)
      #TBD  we don't know

    ok: status == JCRParser::S_OK
      Calling: test_parsing_only( "; Hello\n" "#TBD\n" "#jcr-version 0.5\n" ) (234)
      ; Hello
#TBD
#jcr-version 0.5

    ok: status == JCRParser::S_OK
    ok: ! _CrtMemDifference( &s3, &s1, &s2 )

    GrammarParser - Syntax parsing - target_rule_name [test-parsing-only.cpp:237]
    =============================================================================
      : ParserHarness ph( "my_rule other_rule\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::TARGET_RULE
    ok: ph.grammar().rules[0].target_rule.local_name == "other_rule"
      : ParserHarness ph( "#import http://foo.bar as foo\n my_rule foo.other_rule\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::TARGET_RULE
    ok: ph.grammar().rules[0].target_rule.rulesetid == "http://foo.bar"
    ok: ph.grammar().rules[0].target_rule.local_name == "other_rule"
      Calling: test_parsing_only( "my_rule @{root} other_rule\n" ) (257)
      my_rule @{root} other_rule

    ok: status == JCRParser::S_OK
    ok: ! _CrtMemDifference( &s3, &s1, &s2 )

    GrammarParser - Syntax parsing - Primitive rules [test-parsing-only.cpp:260]
    ============================================================================
      : ParserHarness ph( "my_rule : flubber\n" )
    ok: ph.status() != JCRParser::S_OK
      : ParserHarness ph( "my_rule : null\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::TNULL
    ok: ph.grammar().rules[0].repetition.min == 1
    ok: ph.grammar().rules[0].repetition.max == 1
      : ParserHarness ph( "my_rule :null\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::TNULL
    ok: ph.grammar().rules[0].repetition.min == 1
    ok: ph.grammar().rules[0].repetition.max == 1
      : ParserHarness ph( "my_rule: null\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::TNULL
    ok: ph.grammar().rules[0].repetition.min == 1
    ok: ph.grammar().rules[0].repetition.max == 1
      : ParserHarness ph( "my_rule:null\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::TNULL
    ok: ph.grammar().rules[0].repetition.min == 1
    ok: ph.grammar().rules[0].repetition.max == 1
      : ParserHarness ph( "another_rule : boolean\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "another_rule"
    ok: ph.grammar().rules[0].type == Rule::BOOLEAN
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "another_rule : true\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "another_rule"
    ok: ph.grammar().rules[0].type == Rule::BOOLEAN
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min == "true"
    ok: ph.grammar().rules[0].min.to_bool() == true
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max == "true"
    ok: ph.grammar().rules[0].max.to_bool() == true
      : ParserHarness ph( "another_rule : false\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "another_rule"
    ok: ph.grammar().rules[0].type == Rule::BOOLEAN
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min == "false"
    ok: ph.grammar().rules[0].min.to_bool() == false
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max == "false"
    ok: ph.grammar().rules[0].max.to_bool() == false
      : ParserHarness ph( "rule-2 : string\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::STRING_TYPE
      : ParserHarness ph( "rule-2 : \"a string\"\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::STRING_LITERAL
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min == "a string"
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max == "a string"
      : ParserHarness ph( "rule-2 : /pref\\d+/i\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::STRING_REGEX
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min == "/pref\\d+/i"
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max == "/pref\\d+/i"
      : ParserHarness ph( "rule-2 : float\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::FLOAT
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "rule-2 : 1.0..\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::FLOAT
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min.to_float() == 1.0
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "rule-2 : -1.0..3.5e-2\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::FLOAT
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min.to_float() == -1.0
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.to_float() == 3.5e-2
      : ParserHarness ph( "rule-2 : -1.0..-3.5e-2\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::FLOAT
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min.to_float() == -1.0
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.to_float() == -3.5e-2
      : ParserHarness ph( "rule-2 : ..-3.5e-2\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::FLOAT
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.to_float() == -3.5e-2
      : ParserHarness ph( "rule-2 : 4.0\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::FLOAT
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min.to_float() == 4.0
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.to_float() == 4.0
      : ParserHarness ph( "rule-2 : -3.5e-2\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::FLOAT
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min.to_float() == -3.5e-2
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.to_float() == -3.5e-2
      : ParserHarness ph( "rule-2 : integer\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "rule-2 : 100..\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min.to_int() == 100
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "rule-2 : -100..-50\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].min.to_int() == -100
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.to_int() == -50
      : ParserHarness ph( "rule-2 : ..50\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.to_int() == 50
      : ParserHarness ph( "rule-2 : 64\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].max.to_int() == 64
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max.to_int() == 64
      : ParserHarness ph( "rule-2 : ip4\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::IP4
      : ParserHarness ph( "rule-2 : ip6\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::IP6
      : ParserHarness ph( "rule-2 : idn\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::IDN
      : ParserHarness ph( "rule-2 : fqdn\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::FQDN
      : ParserHarness ph( "rule-2 : uri..http://example.com/foo#place\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::URI_RANGE
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].max == "http://example.com/foo#place"
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max == "http://example.com/foo#place"
      : ParserHarness ph( "rule-2 : uri..http://example.com/foo#place" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::URI_RANGE
    ok: ph.grammar().rules[0].min.is_set() == true
    ok: ph.grammar().rules[0].max == "http://example.com/foo#place"
    ok: ph.grammar().rules[0].max.is_set() == true
    ok: ph.grammar().rules[0].max == "http://example.com/foo#place"
      : ParserHarness ph( "rule-2 : uri\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::URI_TYPE
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "rule-2 : phone\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::PHONE
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "rule-2 : email\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::EMAIL
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "rule-2 : full-date\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::DATE
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "rule-2 : full-time\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::TIME
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "rule-2 : date-time\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::DATETIME
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "rule-2 : base64\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::BASE64
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "rule-2 : any\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "rule-2"
    ok: ph.grammar().rules[0].type == Rule::ANY
    ok: ph.grammar().rules[0].min.is_set() == false
    ok: ph.grammar().rules[0].max.is_set() == false
      : ParserHarness ph( "my_rule @{root} : null\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].annotations.is_root == true
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::TNULL
    ok: ! _CrtMemDifference( &s3, &s1, &s2 )

    GrammarParser - Syntax parsing - root rule [test-parsing-only.cpp:653]
    ======================================================================
      : ParserHarness ph( " : integer" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == ""
    ok: ph.grammar().rules[0].annotations.is_root == true
    ok: ph.grammar().rules[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].repetition.min == 1
    ok: ph.grammar().rules[0].repetition.max == 1
      : ParserHarness ph( ": integer \n my_rule : null\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 2
    ok: ph.grammar().rules[0].rule_name == ""
    ok: ph.grammar().rules[0].type == Rule::INTEGER
    ok: ph.grammar().rules[1].rule_name == "my_rule"
    ok: ph.grammar().rules[1].type == Rule::TNULL
      : ParserHarness ph( "#ruleset-id http://example.com/jcr\n : integer \n my_rule : null\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().ruleset_id == "http://example.com/jcr"
    ok: ph.grammar().rules.size() == 2
    ok: ph.grammar().rules[0].rule_name == ""
    ok: ph.grammar().rules[0].type == Rule::INTEGER
    ok: ph.grammar().rules[1].rule_name == "my_rule"
    ok: ph.grammar().rules[1].type == Rule::TNULL
      Calling: test_parsing_bad_input( ": junk\n" ) (686)
      : junk

    ok: status != JCRParser::S_OK
      Calling: test_parsing_bad_input( "* junk\n" ) (688)
      * junk

    ok: status != JCRParser::S_OK
    ok: ! _CrtMemDifference( &s3, &s1, &s2 )

    GrammarParser - Syntax parsing - Member name [test-parsing-only.cpp:691]
    ========================================================================
      : ParserHarness ph( "my_rule \"Fred\" : null\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].member_name.is_literal() == true
    ok: ph.grammar().rules[0].member_name.name() == "Fred"
    ok: ph.grammar().rules[0].type == Rule::TNULL
      : ParserHarness ph( "my_rule /p_ref\\d+/i : null\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].member_name.is_regex() == true
    ok: ph.grammar().rules[0].member_name.name() == "/p_ref\\d+/i"
    ok: ph.grammar().rules[0].type == Rule::TNULL
      : ParserHarness ph( "my_rule /p_ref\\d+/i my_type\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].member_name.is_regex() == true
    ok: ph.grammar().rules[0].member_name.name() == "/p_ref\\d+/i"
    ok: ph.grammar().rules[0].type == Rule::TARGET_RULE
    ok: ph.grammar().rules[0].target_rule.local_name == "my_type"
      Calling: test_parsing_bad_input( "my_rule /p_ref\\d+/i * integer\n" ) (722)
      my_rule /p_ref\d+/i * integer

    ok: status != JCRParser::S_OK
    ok: ! _CrtMemDifference( &s3, &s1, &s2 )

    GrammarParser - Syntax parsing - type-choice [test-parsing-only.cpp:725]
    ========================================================================
      : ParserHarness ph( "my_rule : (: null)\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::TYPE_CHOICE
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].rule_name == ""
    ok: ph.grammar().rules[0].children[0].type == Rule::TNULL
      : ParserHarness ph( "my_rule : ( : null | : integer )\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::TYPE_CHOICE
    ok: ph.grammar().rules[0].children.size() == 2
    ok: ph.grammar().rules[0].children[0].rule_name == ""
    ok: ph.grammar().rules[0].children[0].type == Rule::TNULL
    ok: ph.grammar().rules[0].children[1].type == Rule::INTEGER
      : ParserHarness ph( "my_rule : ( : null | : integer | : \"my string\" )\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::TYPE_CHOICE
    ok: ph.grammar().rules[0].children.size() == 3
    ok: ph.grammar().rules[0].children[0].rule_name == ""
    ok: ph.grammar().rules[0].children[0].type == Rule::TNULL
    ok: ph.grammar().rules[0].children[1].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[2].type == Rule::STRING_LITERAL
    ok: ph.grammar().rules[0].children[2].min == "my string"
      : ParserHarness ph( "my_rule : ( : null | ( : integer | : float ) | : \"my string\" )\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::TYPE_CHOICE
    ok: ph.grammar().rules[0].children.size() == 3
    ok: ph.grammar().rules[0].children[0].rule_name == ""
    ok: ph.grammar().rules[0].children[0].type == Rule::TNULL
    ok: ph.grammar().rules[0].children[1].type == Rule::TYPE_CHOICE
    ok: ph.grammar().rules[0].children[1].children.size() == 2
    ok: ph.grammar().rules[0].children[1].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[1].children[1].type == Rule::FLOAT
    ok: ph.grammar().rules[0].children[2].type == Rule::STRING_LITERAL
    ok: ph.grammar().rules[0].children[2].min == "my string"
      : ParserHarness ph( "#import http://common.com as common \n my_rule : ( : null | common.my_type )\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::TYPE_CHOICE
    ok: ph.grammar().rules[0].children.size() == 2
    ok: ph.grammar().rules[0].children[0].type == Rule::TNULL
    ok: ph.grammar().rules[0].children[1].type == Rule::TARGET_RULE
    ok: ph.grammar().rules[0].children[1].target_rule.rulesetid == "http://common.com"
    ok: ph.grammar().rules[0].children[1].target_rule.local_name == "my_type"
      : ParserHarness ph( "my_rule : @{reject} ( : null | : integer )\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::TYPE_CHOICE
    ok: ph.grammar().rules[0].annotations.reject == true
    ok: ph.grammar().rules[0].children.size() == 2
    ok: ph.grammar().rules[0].children[0].rule_name == ""
    ok: ph.grammar().rules[0].children[0].type == Rule::TNULL
    ok: ph.grammar().rules[0].children[1].type == Rule::INTEGER
      Calling: test_parsing_bad_input( "my_rule : ( )\n" ) (808)
      my_rule : ( )

    ok: status != JCRParser::S_OK
      Calling: test_parsing_bad_input( "my_rule : ( | )\n" ) (810)
      my_rule : ( | )

    ok: status != JCRParser::S_OK
      Calling: test_parsing_bad_input( "my_rule : ( : integer | )\n" ) (812)
      my_rule : ( : integer | )

    ok: status != JCRParser::S_OK
      Calling: test_parsing_bad_input( "my_rule : ( : integer * )\n" ) (814)
      my_rule : ( : integer * )

    ok: status != JCRParser::S_OK
      Calling: test_parsing_bad_input( "my_rule : ( : integer : null )\n" ) (816)
      my_rule : ( : integer : null )

    ok: status != JCRParser::S_OK
    ok: ! _CrtMemDifference( &s3, &s1, &s2 )

    GrammarParser - Syntax parsing - array [test-parsing-only.cpp:819]
    ==================================================================
      : ParserHarness ph( "my_rule [ : integer ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].rule_name == ""
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
      : ParserHarness ph( "my_rule [ *: integer ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].rule_name == ""
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].repetition.min == 0
    ok: ph.grammar().rules[0].children[0].repetition.max == -1
      : ParserHarness ph( "my_rule : [ *: integer ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].rule_name == ""
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].repetition.min == 0
    ok: ph.grammar().rules[0].children[0].repetition.max == -1
      : ParserHarness ph( "my_rule \"MyName\" [ *: integer ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].member_name.name() == "MyName"
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].rule_name == ""
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].repetition.min == 0
    ok: ph.grammar().rules[0].children[0].repetition.max == -1
      : ParserHarness ph( "my_rule \"MyName\":[ *: integer ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].member_name.name() == "MyName"
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].rule_name == ""
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].repetition.min == 0
    ok: ph.grammar().rules[0].children[0].repetition.max == -1
      : ParserHarness ph( "my_rule [ : integer, : string ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].child_combiner == Rule::Sequence
    ok: ph.grammar().rules[0].children.size() == 2
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[1].type == Rule::STRING_TYPE
      : ParserHarness ph( "my_rule [ : integer | : string ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].child_combiner == Rule::Choice
    ok: ph.grammar().rules[0].children.size() == 2
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[1].type == Rule::STRING_TYPE
      : ParserHarness ph( "my_rule [ : integer | my_type ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].child_combiner == Rule::Choice
    ok: ph.grammar().rules[0].children.size() == 2
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[1].type == Rule::TARGET_RULE
    ok: ph.grammar().rules[0].children[1].target_rule.local_name == "my_type"
      : ParserHarness ph( "my_rule [ 5 (: integer | : string) ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].child_combiner == Rule::None
    ok: ph.grammar().rules[0].children[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children[0].repetition.min == 5
    ok: ph.grammar().rules[0].children[0].repetition.max == 5
    ok: ph.grammar().rules[0].children[0].children.size() == 2
    ok: ph.grammar().rules[0].children[0].child_combiner == Rule::Choice
    ok: ph.grammar().rules[0].children[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].children[1].type == Rule::STRING_TYPE
      : ParserHarness ph( "my_rule [ 5 :float, (: integer | : string) ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 2
    ok: ph.grammar().rules[0].child_combiner == Rule::Sequence
    ok: ph.grammar().rules[0].children[0].type == Rule::FLOAT
    ok: ph.grammar().rules[0].children[0].repetition.min == 5
    ok: ph.grammar().rules[0].children[0].repetition.max == 5
    ok: ph.grammar().rules[0].children[1].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children[1].children.size() == 2
    ok: ph.grammar().rules[0].children[1].child_combiner == Rule::Choice
    ok: ph.grammar().rules[0].children[1].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[1].children[1].type == Rule::STRING_TYPE
      : ParserHarness ph( "my_rule [ 5 :float, ? (: integer | : string) ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 2
    ok: ph.grammar().rules[0].child_combiner == Rule::Sequence
    ok: ph.grammar().rules[0].children[0].type == Rule::FLOAT
    ok: ph.grammar().rules[0].children[0].repetition.min == 5
    ok: ph.grammar().rules[0].children[0].repetition.max == 5
    ok: ph.grammar().rules[0].children[1].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children[1].repetition.min == 0
    ok: ph.grammar().rules[0].children[1].repetition.max == 1
    ok: ph.grammar().rules[0].children[1].children.size() == 2
    ok: ph.grammar().rules[0].children[1].child_combiner == Rule::Choice
    ok: ph.grammar().rules[0].children[1].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[1].children[1].type == Rule::STRING_TYPE
      : ParserHarness ph( "my_rule [ 5 :float, ? (: integer | +: string) ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 2
    ok: ph.grammar().rules[0].child_combiner == Rule::Sequence
    ok: ph.grammar().rules[0].children[0].type == Rule::FLOAT
    ok: ph.grammar().rules[0].children[0].repetition.min == 5
    ok: ph.grammar().rules[0].children[0].repetition.max == 5
    ok: ph.grammar().rules[0].children[1].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children[1].repetition.min == 0
    ok: ph.grammar().rules[0].children[1].repetition.max == 1
    ok: ph.grammar().rules[0].children[1].children.size() == 2
    ok: ph.grammar().rules[0].children[1].child_combiner == Rule::Choice
    ok: ph.grammar().rules[0].children[1].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[1].children[1].type == Rule::STRING_TYPE
    ok: ph.grammar().rules[0].children[1].children[1].repetition.min == 1
    ok: ph.grammar().rules[0].children[1].children[1].repetition.max == -1
      : ParserHarness ph( "my_rule [ 5 :float, ((: integer, :float) | : string) ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 2
    ok: ph.grammar().rules[0].child_combiner == Rule::Sequence
    ok: ph.grammar().rules[0].children[0].type == Rule::FLOAT
    ok: ph.grammar().rules[0].children[0].repetition.min == 5
    ok: ph.grammar().rules[0].children[0].repetition.max == 5
    ok: ph.grammar().rules[0].children[1].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children[1].children.size() == 2
    ok: ph.grammar().rules[0].children[1].child_combiner == Rule::Choice
    ok: ph.grammar().rules[0].children[1].children[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children[1].children[0].children.size() == 2
    ok: ph.grammar().rules[0].children[1].children[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[1].children[0].children[1].type == Rule::FLOAT
    ok: ph.grammar().rules[0].children[1].children[1].type == Rule::STRING_TYPE
      Calling: test_parsing_bad_input( "my_rule : [: integer, :float | :string ]\n" ) (1026)
      my_rule : [: integer, :float | :string ]

    ok: status != JCRParser::S_OK
      Calling: test_parsing_bad_input( "my_rule : [: integer, ]\n" ) (1028)
      my_rule : [: integer, ]

    ok: status != JCRParser::S_OK
    ok: ! _CrtMemDifference( &s3, &s1, &s2 )

    GrammarParser - Syntax parsing - repetition [test-parsing-only.cpp:1031]
    ========================================================================
      : ParserHarness ph( "my_rule [ : integer ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].rule_name == "my_rule"
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].repetition.min == 1
    ok: ph.grammar().rules[0].children[0].repetition.max == 1
      : ParserHarness ph( "my_rule [ ?: integer ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].repetition.min == 0
    ok: ph.grammar().rules[0].children[0].repetition.max == 1
      : ParserHarness ph( "my_rule [ *: integer ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].repetition.min == 0
    ok: ph.grammar().rules[0].children[0].repetition.max == -1
      : ParserHarness ph( "my_rule [ + : integer ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].repetition.min == 1
    ok: ph.grammar().rules[0].children[0].repetition.max == -1
      : ParserHarness ph( "my_rule [ 5 : integer ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].repetition.min == 5
    ok: ph.grammar().rules[0].children[0].repetition.max == 5
      : ParserHarness ph( "my_rule [ 5* : integer ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].repetition.min == 5
    ok: ph.grammar().rules[0].children[0].repetition.max == -1
      : ParserHarness ph( "my_rule [ *5 : integer ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].repetition.min == 0
    ok: ph.grammar().rules[0].children[0].repetition.max == 5
      : ParserHarness ph( "my_rule [ 2*5 : integer ]\n" )
    ok: ph.status() == JCRParser::S_OK
    ok: ph.grammar().rules.size() == 1
    ok: ph.grammar().rules[0].type == Rule::ARRAY
    ok: ph.grammar().rules[0].children.size() == 1
    ok: ph.grammar().rules[0].children[0].type == Rule::INTEGER
    ok: ph.grammar().rules[0].children[0].repetition.min == 2
    ok: ph.grammar().rules[0].children[0].repetition.max == 5
    ok: ! _CrtMemDifference( &s3, &s1, &s2 )
    ok: _CrtCheckMemory() != 0

TODOs (3):
------------------------
- Implement and test GrammarSet::link() [test-grammar-set.cpp:42]
- Test low level GrammarSet class [test-low-level-objects.cpp:198]
- Enhance GrammarParser::q_string() and QStringParser to full spec [test-main.cpp:39]

0 error(s), 3 todo(s), 726 test(s)
